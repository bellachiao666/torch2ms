--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """
 Author: Benny
 Date: Nov 2019
@@ -5,7 +10,7 @@ import argparse
 import os
 from data_utils.ShapeNetDataLoader import PartNormalDataset
-import torch
+# import torch
 import logging
 import sys
 import importlib
@@ -29,7 +34,7 @@ 
 def to_categorical(y, num_classes):
     """ 1-hot encodes a tensor """
-    new_y = torch.eye(num_classes)[y.cpu().data.numpy(),]
+    new_y = mint.eye(num_classes)[y.cpu().data.numpy(),]
     if (y.is_cuda):
         return new_y.cuda()
     return new_y
@@ -71,7 +76,7 @@     root = 'data/shapenetcore_partanno_segmentation_benchmark_v0_normal/'
 
     TEST_DATASET = PartNormalDataset(root=root, npoints=args.num_point, split='test', normal_channel=args.normal)
-    testDataLoader = torch.utils.data.DataLoader(TEST_DATASET, batch_size=args.batch_size, shuffle=False, num_workers=4)
+    testDataLoader = torch.utils.data.DataLoader(TEST_DATASET, batch_size=args.batch_size, shuffle=False, num_workers=4)  # 'torch.utils.data.DataLoader' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
     log_string("The number of test data is: %d" % len(TEST_DATASET))
     num_classes = 16
     num_part = 50
@@ -80,9 +85,10 @@     model_name = os.listdir(experiment_dir + '/logs')[0].split('.')[0]
     MODEL = importlib.import_module(model_name)
     classifier = MODEL.get_model(num_part, normal_channel=args.normal).cuda()
-    checkpoint = torch.load(str(experiment_dir) + '/checkpoints/best_model.pth')
+    checkpoint = torch.load(str(experiment_dir) + '/checkpoints/best_model.pth')  # 'torch.load' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
     classifier.load_state_dict(checkpoint['model_state_dict'])
 
+    # 'torch.no_grad' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
     with torch.no_grad():
         test_metrics = {}
         total_correct = 0
@@ -103,7 +109,7 @@             cur_batch_size, NUM_POINT, _ = points.size()
             points, label, target = points.float().cuda(), label.long().cuda(), target.long().cuda()
             points = points.transpose(2, 1)
-            vote_pool = torch.zeros(target.size()[0], target.size()[1], num_part).cuda()
+            vote_pool = mint.zeros(target.size()[0], target.size()[1], num_part).cuda()
 
             for _ in range(args.num_votes):
                 seg_pred, _ = classifier(points, to_categorical(label, num_classes))
