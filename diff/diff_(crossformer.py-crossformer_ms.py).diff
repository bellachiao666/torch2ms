--- pytorch+++ mindspore@@ -2,7 +2,7 @@ from torch import nn, einsum
 from einops import rearrange
 from einops.layers.torch import Rearrange, Reduce
-import torch.nn.functional as F
+from mindspore.mint import nn, ops
 
 # helpers
 
@@ -11,7 +11,7 @@ 
 # cross embed layer
 
-class CrossEmbedLayer(nn.Module):
+class CrossEmbedLayer(nn.Cell):
     def __init__(
         self,
         dim_in,
@@ -27,55 +27,55 @@         dim_scales = [int(dim_out / (2 ** i)) for i in range(1, num_scales)]
         dim_scales = [*dim_scales, dim_out - sum(dim_scales)]
 
-        self.convs = nn.ModuleList([])
+        self.convs = nn.CellList([])
         for kernel, dim_scale in zip(kernel_sizes, dim_scales):
-            self.convs.append(nn.Conv2d(dim_in, dim_scale, kernel, stride = stride, padding = (kernel - stride) // 2))
+            self.convs.append(nn.Conv2d(in_channels = dim_in, out_channels = dim_scale, kernel_size = kernel, stride = stride, padding = (kernel - stride) // 2))  # 'torch.nn.Conv2d':没有对应的mindspore参数 'device';
 
     def forward(self, x):
         fmaps = tuple(map(lambda conv: conv(x), self.convs))
-        return torch.cat(fmaps, dim = 1)
+        return ops.cat(tensors = fmaps, dim = 1)  # 'torch.cat':没有对应的mindspore参数 'out';
 
 # dynamic positional bias
 
 def DynamicPositionBias(dim):
-    return nn.Sequential(
-        nn.Linear(2, dim),
-        nn.LayerNorm(dim),
+    return nn.SequentialCell(
+        nn.Linear(in_features = 2, out_features = dim),
+        nn.LayerNorm(normalized_shape = dim),
         nn.ReLU(),
-        nn.Linear(dim, dim),
-        nn.LayerNorm(dim),
+        nn.Linear(in_features = dim, out_features = dim),
+        nn.LayerNorm(normalized_shape = dim),
         nn.ReLU(),
-        nn.Linear(dim, dim),
-        nn.LayerNorm(dim),
+        nn.Linear(in_features = dim, out_features = dim),
+        nn.LayerNorm(normalized_shape = dim),
         nn.ReLU(),
-        nn.Linear(dim, 1),
+        nn.Linear(in_features = dim, out_features = 1),
         Rearrange('... () -> ...')
-    )
+    )  # 'torch.nn.Linear':没有对应的mindspore参数 'device';; 'torch.nn.LayerNorm':没有对应的mindspore参数 'device';; 'torch.nn.ReLU':没有对应的mindspore参数 'inplace';
 
 # transformer classes
 
-class LayerNorm(nn.Module):
+class LayerNorm(nn.Cell):
     def __init__(self, dim, eps = 1e-5):
         super().__init__()
         self.eps = eps
-        self.g = nn.Parameter(torch.ones(1, dim, 1, 1))
-        self.b = nn.Parameter(torch.zeros(1, dim, 1, 1))
-
-    def forward(self, x):
-        var = torch.var(x, dim = 1, unbiased = False, keepdim = True)
-        mean = torch.mean(x, dim = 1, keepdim = True)
+        self.g = mindspore.Parameter(ops.ones(size = 1, dtype = 1))  # 'torch.ones':没有对应的mindspore参数 'out';; 'torch.ones':没有对应的mindspore参数 'layout';; 'torch.ones':没有对应的mindspore参数 'device';; 'torch.ones':没有对应的mindspore参数 'requires_grad';
+        self.b = mindspore.Parameter(ops.zeros(size = 1, dtype = 1))  # 'torch.zeros':没有对应的mindspore参数 'out';; 'torch.zeros':没有对应的mindspore参数 'layout';; 'torch.zeros':没有对应的mindspore参数 'device';; 'torch.zeros':没有对应的mindspore参数 'requires_grad';
+
+    def forward(self, x):
+        var = ops.var(input = x, dim = 1, keepdim = True)  # 'torch.var':没有对应的mindspore参数 'out';
+        mean = ops.mean(input = x, dim = 1, keepdim = True)
         return (x - mean) / (var + self.eps).sqrt() * self.g + self.b
 
 def FeedForward(dim, mult = 4, dropout = 0.):
-    return nn.Sequential(
+    return nn.SequentialCell(
         LayerNorm(dim),
-        nn.Conv2d(dim, dim * mult, 1),
+        nn.Conv2d(in_channels = dim, out_channels = dim * mult, kernel_size = 1),
         nn.GELU(),
-        nn.Dropout(dropout),
-        nn.Conv2d(dim * mult, dim, 1)
-    )
-
-class Attention(nn.Module):
+        nn.Dropout(p = dropout),
+        nn.Conv2d(in_channels = dim * mult, out_channels = dim, kernel_size = 1)
+    )  # 'torch.nn.Conv2d':没有对应的mindspore参数 'device';
+
+class Attention(nn.Cell):
     def __init__(
         self,
         dim,
@@ -96,10 +96,10 @@ 
         self.norm = LayerNorm(dim)
 
-        self.dropout = nn.Dropout(dropout)
-
-        self.to_qkv = nn.Conv2d(dim, inner_dim * 3, 1, bias = False)
-        self.to_out = nn.Conv2d(inner_dim, dim, 1)
+        self.dropout = nn.Dropout(p = dropout)
+
+        self.to_qkv = nn.Conv2d(in_channels = dim, out_channels = inner_dim * 3, kernel_size = 1, bias = False)  # 'torch.nn.Conv2d':没有对应的mindspore参数 'device';
+        self.to_out = nn.Conv2d(in_channels = inner_dim, out_channels = dim, kernel_size = 1)  # 'torch.nn.Conv2d':没有对应的mindspore参数 'device';
 
         # positions
 
@@ -107,8 +107,8 @@ 
         # calculate and store indices for retrieving bias
 
-        pos = torch.arange(window_size)
-        grid = torch.stack(torch.meshgrid(pos, pos, indexing = 'ij'))
+        pos = ops.arange(start = window_size)  # 'torch.arange':没有对应的mindspore参数 'out';; 'torch.arange':没有对应的mindspore参数 'layout';; 'torch.arange':没有对应的mindspore参数 'device';; 'torch.arange':没有对应的mindspore参数 'requires_grad';
+        grid = ops.stack(tensors = ops.meshgrid(tensors = pos, indexing = 'ij'))  # 'torch.stack':没有对应的mindspore参数 'out';
         grid = rearrange(grid, 'c i j -> (i j) c')
         rel_pos = grid[:, None] - grid[None, :]
         rel_pos += window_size - 1
@@ -139,12 +139,12 @@         q, k, v = map(lambda t: rearrange(t, 'b (h d) x y -> b h (x y) d', h = heads), (q, k, v))
         q = q * self.scale
 
-        sim = einsum('b h i d, b h j d -> b h i j', q, k)
+        sim = ops.einsum(equation = 'b h i d, b h j d -> b h i j', operands = q)
 
         # add dynamic positional bias
 
-        pos = torch.arange(-wsz, wsz + 1, device = device)
-        rel_pos = torch.stack(torch.meshgrid(pos, pos, indexing = 'ij'))
+        pos = ops.arange(start = -wsz, end = wsz + 1)  # 'torch.arange':没有对应的mindspore参数 'out';; 'torch.arange':没有对应的mindspore参数 'layout';; 'torch.arange':没有对应的mindspore参数 'device';; 'torch.arange':没有对应的mindspore参数 'requires_grad';
+        rel_pos = ops.stack(tensors = ops.meshgrid(tensors = pos, indexing = 'ij'))  # 'torch.stack':没有对应的mindspore参数 'out';
         rel_pos = rearrange(rel_pos, 'c i j -> (i j) c')
         biases = self.dpb(rel_pos.float())
         rel_pos_bias = biases[self.rel_pos_indices]
@@ -158,7 +158,7 @@ 
         # merge heads
 
-        out = einsum('b h i j, b h j d -> b h i d', attn, v)
+        out = ops.einsum(equation = 'b h i j, b h j d -> b h i d', operands = attn)
         out = rearrange(out, 'b h (x y) d -> b (h d) x y', x = wsz, y = wsz)
         out = self.to_out(out)
 
@@ -171,7 +171,7 @@ 
         return out
 
-class Transformer(nn.Module):
+class Transformer(nn.Cell):
     def __init__(
         self,
         dim,
@@ -184,10 +184,10 @@         ff_dropout = 0.,
     ):
         super().__init__()
-        self.layers = nn.ModuleList([])
+        self.layers = nn.CellList([])
 
         for _ in range(depth):
-            self.layers.append(nn.ModuleList([
+            self.layers.append(nn.CellList([
                 Attention(dim, attn_type = 'short', window_size = local_window_size, dim_head = dim_head, dropout = attn_dropout),
                 FeedForward(dim, dropout = ff_dropout),
                 Attention(dim, attn_type = 'long', window_size = global_window_size, dim_head = dim_head, dropout = attn_dropout),
@@ -205,7 +205,7 @@ 
 # classes
 
-class CrossFormer(nn.Module):
+class CrossFormer(nn.Cell):
     def __init__(
         self,
         *,
@@ -244,20 +244,20 @@ 
         # layers
 
-        self.layers = nn.ModuleList([])
+        self.layers = nn.CellList([])
 
         for (dim_in, dim_out), layers, global_wsz, local_wsz, cel_kernel_sizes, cel_stride in zip(dim_in_and_out, depth, global_window_size, local_window_size, cross_embed_kernel_sizes, cross_embed_strides):
-            self.layers.append(nn.ModuleList([
+            self.layers.append(nn.CellList([
                 CrossEmbedLayer(dim_in, dim_out, cel_kernel_sizes, stride = cel_stride),
                 Transformer(dim_out, local_window_size = local_wsz, global_window_size = global_wsz, depth = layers, attn_dropout = attn_dropout, ff_dropout = ff_dropout)
             ]))
 
         # final logits
 
-        self.to_logits = nn.Sequential(
+        self.to_logits = nn.SequentialCell(
             Reduce('b c h w -> b c', 'mean'),
-            nn.Linear(last_dim, num_classes)
-        )
+            nn.Linear(in_features = last_dim, out_features = num_classes)
+        )  # 'torch.nn.Linear':没有对应的mindspore参数 'device';
 
     def forward(self, x):
         for cel, transformer in self.layers:
