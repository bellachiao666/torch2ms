--- pytorch+++ mindspore@@ -1,11 +1,10 @@-import torch
 from torch import nn
-import torch.nn.functional as F
 from einops import repeat
 
 from vit_pytorch.vit import Transformer
+from mindspore.mint import nn, ops
 
-class MAE(nn.Module):
+class MAE(nn.Cell):
     def __init__(
         self,
         *,
@@ -32,11 +31,11 @@ 
         # decoder parameters
         self.decoder_dim = decoder_dim
-        self.enc_to_dec = nn.Linear(encoder_dim, decoder_dim) if encoder_dim != decoder_dim else nn.Identity()
-        self.mask_token = nn.Parameter(torch.randn(decoder_dim))
+        self.enc_to_dec = nn.Linear(in_features = encoder_dim, out_features = decoder_dim) if encoder_dim != decoder_dim else nn.Identity()  # 'torch.nn.Linear':没有对应的mindspore参数 'device';
+        self.mask_token = nn.Parameter(ops.randn(size = decoder_dim))  # 'torch.randn':没有对应的mindspore参数 'out';; 'torch.randn':没有对应的mindspore参数 'layout';; 'torch.randn':没有对应的mindspore参数 'device';; 'torch.randn':没有对应的mindspore参数 'requires_grad';; 'torch.randn':没有对应的mindspore参数 'pin_memory';
         self.decoder = Transformer(dim = decoder_dim, depth = decoder_depth, heads = decoder_heads, dim_head = decoder_dim_head, mlp_dim = decoder_dim * 4)
-        self.decoder_pos_emb = nn.Embedding(num_patches, decoder_dim)
-        self.to_pixels = nn.Linear(decoder_dim, pixel_values_per_patch)
+        self.decoder_pos_emb = nn.Embedding(num_embeddings = num_patches, embedding_dim = decoder_dim)  # 'torch.nn.Embedding':没有对应的mindspore参数 'device';
+        self.to_pixels = nn.Linear(in_features = decoder_dim, out_features = pixel_values_per_patch)  # 'torch.nn.Linear':没有对应的mindspore参数 'device';
 
     def forward(self, img):
         device = img.device
@@ -57,12 +56,12 @@         # calculate of patches needed to be masked, and get random indices, dividing it up for mask vs unmasked
 
         num_masked = int(self.masking_ratio * num_patches)
-        rand_indices = torch.rand(batch, num_patches, device = device).argsort(dim = -1)
+        rand_indices = ops.rand(size = batch, generator = num_patches).argsort(dim = -1)  # 'torch.rand':没有对应的mindspore参数 'out';; 'torch.rand':没有对应的mindspore参数 'layout';; 'torch.rand':没有对应的mindspore参数 'device';; 'torch.rand':没有对应的mindspore参数 'requires_grad';; 'torch.rand':没有对应的mindspore参数 'pin_memory';
         masked_indices, unmasked_indices = rand_indices[:, :num_masked], rand_indices[:, num_masked:]
 
         # get the unmasked tokens to be encoded
 
-        batch_range = torch.arange(batch, device = device)[:, None]
+        batch_range = ops.arange(start = batch)[:, None]  # 'torch.arange':没有对应的mindspore参数 'out';; 'torch.arange':没有对应的mindspore参数 'layout';; 'torch.arange':没有对应的mindspore参数 'device';; 'torch.arange':没有对应的mindspore参数 'requires_grad';
         tokens = tokens[batch_range, unmasked_indices]
 
         # get the patches to be masked for the final reconstruction loss
@@ -88,7 +87,7 @@ 
         # concat the masked tokens to the decoder tokens and attend with decoder
         
-        decoder_tokens = torch.zeros(batch, num_patches, self.decoder_dim, device=device)
+        decoder_tokens = ops.zeros(size = batch, dtype = self.decoder_dim)  # 'torch.zeros':没有对应的mindspore参数 'out';; 'torch.zeros':没有对应的mindspore参数 'layout';; 'torch.zeros':没有对应的mindspore参数 'device';; 'torch.zeros':没有对应的mindspore参数 'requires_grad';
         decoder_tokens[batch_range, unmasked_indices] = unmasked_decoder_tokens
         decoder_tokens[batch_range, masked_indices] = mask_tokens
         decoded_tokens = self.decoder(decoder_tokens)
@@ -100,5 +99,5 @@ 
         # calculate reconstruction loss
 
-        recon_loss = F.mse_loss(pred_pixel_values, masked_patches)
+        recon_loss = nn.functional.mse_loss(input = pred_pixel_values, target = masked_patches)  # 'torch.nn.functional.mse_loss':没有对应的mindspore参数 'size_average';; 'torch.nn.functional.mse_loss':没有对应的mindspore参数 'reduce';
         return recon_loss
