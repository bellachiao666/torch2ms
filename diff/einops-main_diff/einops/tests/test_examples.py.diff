--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 import numpy as np
 import pytest
 
@@ -43,7 +48,7 @@         t = t[:, ::2]  # replacement for dot-product, just changes size of second axis
         assert tuple(t.shape) == (10 * 30 * 40, 10)
 
-        y = rearrange(t, "(b h w) c2 -> b c2 h w", **parse_shape(x, "b _ h w"))
+        y = rearrange(t, "(b h w) c2 -> b c2 h w", **parse_shape(x, "b _ h w"))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         assert tuple(y.shape) == (10, 10, 30, 40)
         return y
 
@@ -195,7 +200,7 @@     if not is_backend_tested("torch"):
         pytest.skip()
 
-    import torch
+    # import torch
 
     def old_way(tensor, num_classes, num_anchors, anchors, stride_h, stride_w):
         # https://github.com/BobLiu20/YOLOv3_PyTorch/blob/c6b483743598b5f64d520d81e7e5f47ba936d4c9/nets/yolo_loss.py#L28-L44
@@ -206,26 +211,26 @@ 
         prediction = tensor.view(bs, num_anchors, 5 + num_classes, in_h, in_w).permute(0, 1, 3, 4, 2).contiguous()
         # Get outputs
-        x = torch.sigmoid(prediction[..., 0])  # Center x
-        y = torch.sigmoid(prediction[..., 1])  # Center y
+        x = mint.sigmoid(prediction[..., 0])  # Center x
+        y = mint.sigmoid(prediction[..., 1])  # Center y
         w = prediction[..., 2]  # Width
         h = prediction[..., 3]  # Height
-        conf = torch.sigmoid(prediction[..., 4])  # Conf
-        pred_cls = torch.sigmoid(prediction[..., 5:])  # Cls pred.
+        conf = mint.sigmoid(prediction[..., 4])  # Conf
+        pred_cls = mint.sigmoid(prediction[..., 5:])  # Cls pred.
 
         # https://github.com/BobLiu20/YOLOv3_PyTorch/blob/c6b483743598b5f64d520d81e7e5f47ba936d4c9/nets/yolo_loss.py#L70-L92
         FloatTensor = torch.cuda.FloatTensor if x.is_cuda else torch.FloatTensor
         LongTensor = torch.cuda.LongTensor if x.is_cuda else torch.LongTensor
         # Calculate offsets for each grid
         grid_x = (
-            torch.linspace(0, in_w - 1, in_w)
+            mint.linspace(0, in_w - 1, in_w)
             .repeat(in_w, 1)
             .repeat(bs * num_anchors, 1, 1)
             .view(x.shape)
             .type(FloatTensor)
         )
         grid_y = (
-            torch.linspace(0, in_h - 1, in_h)
+            mint.linspace(0, in_h - 1, in_h)
             .repeat(in_h, 1)
             .t()
             .repeat(bs * num_anchors, 1, 1)
@@ -241,11 +246,11 @@         pred_boxes = FloatTensor(prediction[..., :4].shape)
         pred_boxes[..., 0] = x.data + grid_x
         pred_boxes[..., 1] = y.data + grid_y
-        pred_boxes[..., 2] = torch.exp(w.data) * anchor_w
-        pred_boxes[..., 3] = torch.exp(h.data) * anchor_h
+        pred_boxes[..., 2] = mint.exp(w.data) * anchor_w
+        pred_boxes[..., 3] = mint.exp(h.data) * anchor_h
         # Results
-        _scale = torch.Tensor([stride_w, stride_h] * 2).type(FloatTensor)
-        output = torch.cat(
+        _scale = ms.Tensor([stride_w, stride_h] * 2).type(FloatTensor)
+        output = mint.cat(
             (pred_boxes.view(bs, -1, 4) * _scale, conf.view(bs, -1, 1), pred_cls.view(bs, -1, num_classes)), -1
         )
         return output
@@ -253,14 +258,14 @@     def new_way(tensor, num_classes, num_anchors, anchors, stride_h, stride_w):
         raw_predictions = rearrange(tensor, " b (anchor prediction) h w -> prediction b anchor h w", anchor=num_anchors)
 
-        anchors = torch.FloatTensor(anchors).to(tensor.device)
+        anchors = torch.FloatTensor(anchors).to(tensor.device)  # 'torch.FloatTensor' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;; 'torch.FloatTensor.to' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         anchor_sizes = rearrange(anchors, "anchor dim -> dim () anchor () ()")
 
         _, _, _, in_h, in_w = raw_predictions.shape
-        grid_h = rearrange(torch.arange(in_h).float(), "h -> () () h ()").to(tensor.device)
-        grid_w = rearrange(torch.arange(in_w).float(), "w -> () () () w").to(tensor.device)
-
-        predicted_bboxes = torch.zeros_like(raw_predictions)
+        grid_h = rearrange(mint.arange(in_h).float(), "h -> () () h ()").to(tensor.device)
+        grid_w = rearrange(mint.arange(in_w).float(), "w -> () () () w").to(tensor.device)
+
+        predicted_bboxes = mint.zeros_like(raw_predictions)
         predicted_bboxes[0] = (raw_predictions[0].sigmoid() + grid_h) * stride_h  # center y
         predicted_bboxes[1] = (raw_predictions[1].sigmoid() + grid_w) * stride_w  # center x
         predicted_bboxes[2:4] = (raw_predictions[2:4].exp()) * anchor_sizes  # bbox width and height
@@ -276,7 +281,7 @@     anchors = [[50, 100], [100, 50], [75, 75]]
     num_anchors = len(anchors)
 
-    x = torch.randn([batch_size, num_anchors * (5 + num_classes), 1, 1])
+    x = mint.randn([batch_size, num_anchors * (5 + num_classes), 1, 1])
     result1 = old_way(
         tensor=x,
         num_anchors=num_anchors,
@@ -294,4 +299,4 @@         anchors=anchors,
     )
     result1 = result1.reshape(result2.shape)
-    assert torch.allclose(result1, result2)
+    assert mint.allclose(result1, result2)
