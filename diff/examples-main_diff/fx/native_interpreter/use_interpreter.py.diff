--- pytorch+++ mindspore@@ -1,5 +1,9 @@-import torch
-import torch.fx
+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
+# import torch
 import operator
 
 # Does this path not exist? Check that you've done the following:
@@ -7,7 +11,7 @@ # 2) If this file still does not exist after you've followed those instructions,
 #    check if it is under a different extension (e.g. `dylib` on mac or `dll` on
 #    windows).
-torch.classes.load_library('build/libinterpreter.so')
+torch.classes.load_library('build/libinterpreter.so')  # 'torch.classes.load_library' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
 # This is what a lowering pass should look like: a function that takes
 # a valid nn.Module, symbolically traces it, lowers the Module to some
@@ -16,9 +20,10 @@ # This will ensure that this lowering transformation still fits into the
 # PyTorch programming model and enables features like composing with other
 # transformations and TorchScript compilation.
-def lower_to_elementwise_interpreter(orig_mod : torch.nn.Module) -> torch.nn.Module:
+# 'torch.fx.Node' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+def lower_to_elementwise_interpreter(orig_mod : msnn.Cell) -> msnn.Cell:
     # ===== Stage 1: Symbolic trace the module =====
-    mod = torch.fx.symbolic_trace(orig_mod)
+    mod = torch.fx.symbolic_trace(orig_mod)  # 'torch.fx.symbolic_trace' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
     # ===== Stage 2: Lower GraphModule representation to the C++
     #       interpreter's instruction format ======
@@ -52,7 +57,7 @@                     # Pull out constants. These constants will later be
                     # fed to the interpreter C++ object via add_constant()
                     arg_name = f'constant_{constant_idx}'
-                    constants[arg_name] = torch.Tensor(
+                    constants[arg_name] = ms.Tensor(
                         [arg] if isinstance(arg, numbers.Number) else arg)
                     arg_names.append(arg_name)
                     constant_idx += 1
@@ -66,7 +71,7 @@         else:
             raise RuntimeError('Unsupported opcode ' + n.op)
 
-    interpreter = torch.classes.NativeInterpretation.ElementwiseInterpreter()
+    interpreter = torch.classes.NativeInterpretation.ElementwiseInterpreter()  # 'torch.classes.NativeInterpretation.ElementwiseInterpreter' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
     # Load constants
     for k, v in constants.items():
         interpreter.add_constant(k, v)
@@ -79,7 +84,7 @@     interpreter.set_output_name(output_node.args[0].name)
 
     # ===== Stage 3: Create a wrapper GraphModule around the interpreter =====
-    class WrapperModule(torch.nn.Module):
+    class WrapperModule(msnn.Cell):
         def __init__(self, interpreter):
             super().__init__()
             self.interpreter = interpreter
@@ -90,7 +95,7 @@     # Create a graph that: 1) Takes function arguments 2) Invokes the interpreter
     # 3) Returns the specified return value
 
-    graph = torch.fx.Graph()
+    graph = torch.fx.Graph()  # 'torch.fx.Graph' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
     # Add placeholders for fn inputs
     placeholder_nodes = []
     for name in fn_input_names:
@@ -109,21 +114,21 @@     graph.lint(wrapper)
 
     # Return final GraphModule!!!
-    return torch.fx.GraphModule(wrapper, graph)
+    return torch.fx.GraphModule(wrapper, graph)  # 'torch.fx.GraphModule' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
-class MyElementwiseModule(torch.nn.Module):
-    def forward(self, x, y):
+class MyElementwiseModule(msnn.Cell):
+    def construct(self, x, y):
         return x * y + y
 
 mem = MyElementwiseModule()
 lowered = lower_to_elementwise_interpreter(mem)
 print(lowered.code)
 # The lowered module can also be compiled into TorchScript
-scripted = torch.jit.script(lowered)
+scripted = ms.jit(lowered)
 print(scripted.graph)
 
 # Stress test correctness
 for _ in range(50):
-    x, y = torch.randn(10, 20, 30), torch.randn(10, 20, 30)
-    torch.testing.assert_allclose(lowered(x, y), mem(x, y))
-    torch.testing.assert_allclose(scripted(x, y), mem(x, y))
+    x, y = mint.randn(10, 20, 30), mint.randn(10, 20, 30)
+    torch.testing.assert_allclose(lowered(x, y), mem(x, y))  # 'torch.testing.assert_allclose' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+    torch.testing.assert_allclose(scripted(x, y), mem(x, y))  # 'torch.testing.assert_allclose' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
