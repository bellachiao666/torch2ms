--- pytorch+++ mindspore@@ -1,5 +1,10 @@-import torch
-from torch.fx import Proxy, Graph, GraphModule
+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
+# import torch
+# from torch.fx import Proxy, Graph, GraphModule
 
 
 '''
@@ -31,29 +36,29 @@ 
 
 # Create a graph independently of symbolic tracing
-graph = Graph()
-tracer = torch.fx.proxy.GraphAppendingTracer(graph)
+graph = Graph()  # 'torch.fx.Graph' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+tracer = torch.fx.proxy.GraphAppendingTracer(graph)  # 'torch.fx.proxy.GraphAppendingTracer' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
 # Create raw Nodes
 raw1 = graph.placeholder('x')
 raw2 = graph.placeholder('y')
 
 # Initialize Proxies using the raw Nodes and graph's default tracer
-y = Proxy(raw1, tracer)
-z = Proxy(raw2, tracer)
+y = Proxy(raw1, tracer)  # 'torch.fx.Proxy' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+z = Proxy(raw2, tracer)  # 'torch.fx.Proxy' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 # y = Proxy(raw1)
 # z = Proxy(raw2)
 
 # Create other operations using the Proxies `y` and `z`
-a = torch.cat([y, z])
-b = torch.tanh(a)
-c = torch.neg(b)
+a = mint.cat([y, z])
+b = mint.tanh(a)
+c = mint.neg(b)
 # By using the graph's own appending tracer to create Proxies,
 # notice we can now use n-ary operators on operations without
 # multiple tracers being created at run-time (line 52) which leads
 # to errors # To try this out for yourself, replace lines 42, 43
 # with 44, 45
-z = torch.add(b, c)
+z = mint.add(b, c)
 
 # Create a new output Node and add it to the Graph. By doing this, the
 # Graph will contain all the Nodes we just created (since they're all
@@ -62,4 +67,4 @@ 
 # Wrap our created Graph in a GraphModule to get a final, runnable
 # `nn.Module` instance
-mod = GraphModule(torch.nn.Module(), graph)
+mod = GraphModule(msnn.Cell(), graph)  # 'torch.fx.GraphModule' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
