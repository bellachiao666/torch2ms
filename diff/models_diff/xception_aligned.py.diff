--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """Pytorch impl of Aligned Xception 41, 65, 71
 
 This is a correct, from scratch impl of Aligned Xception (Deeplab) models compatible with TF weights at
@@ -8,8 +13,8 @@ from functools import partial
 from typing import List, Dict, Type, Optional
 
-import torch
-import torch.nn as nn
+# import torch
+# import torch.nn as nn
 
 from timm.data import IMAGENET_INCEPTION_MEAN, IMAGENET_INCEPTION_STD
 from timm.layers import ClassifierHead, ConvNormAct, DropPath, PadType, create_conv2d, get_norm_act_layer
@@ -21,7 +26,7 @@ __all__ = ['XceptionAligned']
 
 
-class SeparableConv2d(nn.Module):
+class SeparableConv2d(msnn.Cell):
     def __init__(
             self,
             in_chs: int,
@@ -30,8 +35,8 @@             stride: int = 1,
             dilation: int = 1,
             padding: PadType = '',
-            act_layer: Type[nn.Module] = nn.ReLU,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
             device=None,
             dtype=None,
     ):
@@ -52,14 +57,14 @@             **dd,
         )
         self.bn_dw = norm_layer(in_chs, **dd)
-        self.act_dw = act_layer(inplace=True) if act_layer is not None else nn.Identity()
+        self.act_dw = act_layer(inplace=True) if act_layer is not None else msnn.Identity()
 
         # pointwise convolution
         self.conv_pw = create_conv2d(in_chs, out_chs, kernel_size=1, **dd)
         self.bn_pw = norm_layer(out_chs, **dd)
-        self.act_pw = act_layer(inplace=True) if act_layer is not None else nn.Identity()
-
-    def forward(self, x):
+        self.act_pw = act_layer(inplace=True) if act_layer is not None else msnn.Identity()
+
+    def construct(self, x):
         x = self.conv_dw(x)
         x = self.bn_dw(x)
         x = self.act_dw(x)
@@ -69,7 +74,7 @@         return x
 
 
-class PreSeparableConv2d(nn.Module):
+class PreSeparableConv2d(msnn.Cell):
     def __init__(
             self,
             in_chs: int,
@@ -78,8 +83,8 @@             stride: int = 1,
             dilation: int = 1,
             padding: PadType = '',
-            act_layer: Type[nn.Module] = nn.ReLU,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
             first_act: bool = True,
             device=None,
             dtype=None,
@@ -90,7 +95,7 @@         self.kernel_size = kernel_size
         self.dilation = dilation
 
-        self.norm = norm_act_layer(in_chs, inplace=True, **dd) if first_act else nn.Identity()
+        self.norm = norm_act_layer(in_chs, inplace=True, **dd) if first_act else msnn.Identity()
         # depthwise convolution
         self.conv_dw = create_conv2d(
             in_chs,
@@ -106,14 +111,14 @@         # pointwise convolution
         self.conv_pw = create_conv2d(in_chs, out_chs, kernel_size=1, **dd)
 
-    def forward(self, x):
+    def construct(self, x):
         x = self.norm(x)
         x = self.conv_dw(x)
         x = self.conv_pw(x)
         return x
 
 
-class XceptionModule(nn.Module):
+class XceptionModule(msnn.Cell):
     def __init__(
             self,
             in_chs: int,
@@ -123,9 +128,9 @@             pad_type: PadType = '',
             start_with_relu: bool = True,
             no_skip: bool = False,
-            act_layer: Type[nn.Module] = nn.ReLU,
-            norm_layer: Optional[Type[nn.Module]] = None,
-            drop_path: Optional[nn.Module] = None,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
+            norm_layer: Optional[Type[msnn.Cell]] = None,
+            drop_path: Optional[msnn.Cell] = None,
             device=None,
             dtype=None,
     ):
@@ -149,7 +154,7 @@             self.shortcut = None
 
         separable_act_layer = None if start_with_relu else act_layer
-        self.stack = nn.Sequential()
+        self.stack = msnn.SequentialCell()
         for i in range(3):
             if start_with_relu:
                 self.stack.add_module(f'act{i + 1}', act_layer(inplace=i > 0))
@@ -168,7 +173,7 @@ 
         self.drop_path = drop_path
 
-    def forward(self, x):
+    def construct(self, x):
         skip = x
         x = self.stack(x)
         if self.shortcut is not None:
@@ -180,7 +185,7 @@         return x
 
 
-class PreXceptionModule(nn.Module):
+class PreXceptionModule(msnn.Cell):
     def __init__(
             self,
             in_chs: int,
@@ -189,9 +194,9 @@             dilation: int = 1,
             pad_type: PadType = '',
             no_skip: bool = False,
-            act_layer: Type[nn.Module] = nn.ReLU,
-            norm_layer: Optional[Type[nn.Module]] = None,
-            drop_path: Optional[nn.Module] = None,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
+            norm_layer: Optional[Type[msnn.Cell]] = None,
+            drop_path: Optional[msnn.Cell] = None,
             device=None,
             dtype=None,
     ):
@@ -204,10 +209,10 @@         if not no_skip and (self.out_channels != self.in_channels or stride != 1):
             self.shortcut = create_conv2d(in_chs, self.out_channels, 1, stride=stride, **dd)
         else:
-            self.shortcut = nn.Identity()
+            self.shortcut = msnn.Identity()
 
         self.norm = get_norm_act_layer(norm_layer, act_layer=act_layer)(in_chs, inplace=True, **dd)
-        self.stack = nn.Sequential()
+        self.stack = msnn.SequentialCell()
         for i in range(3):
             self.stack.add_module(f'conv{i + 1}', PreSeparableConv2d(
                 in_chs,
@@ -225,7 +230,7 @@ 
         self.drop_path = drop_path
 
-    def forward(self, x):
+    def construct(self, x):
         x = self.norm(x)
         skip = x
         x = self.stack(x)
@@ -236,7 +241,7 @@         return x
 
 
-class XceptionAligned(nn.Module):
+class XceptionAligned(msnn.Cell):
     """Modified Aligned Xception
     """
 
@@ -247,8 +252,8 @@             in_chans: int = 3,
             output_stride: int = 32,
             preact: bool = False,
-            act_layer: Type[nn.Module] = nn.ReLU,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
             drop_rate: float = 0.,
             drop_path_rate: float = 0.,
             global_pool: str = 'avg',
@@ -263,7 +268,7 @@         self.grad_checkpointing = False
 
         layer_args = dict(act_layer=act_layer, norm_layer=norm_layer, **dd)
-        self.stem = nn.Sequential(*[
+        self.stem = msnn.SequentialCell(*[
             ConvNormAct(in_chans, 32, kernel_size=3, stride=2, **layer_args),
             create_conv2d(32, 64, kernel_size=3, stride=1, **dd) if preact else
             ConvNormAct(32, 64, kernel_size=3, stride=1, **layer_args)
@@ -272,7 +277,7 @@         curr_dilation = 1
         curr_stride = 2
         self.feature_info = []
-        self.blocks = nn.Sequential()
+        self.blocks = msnn.SequentialCell()
         module_fn = PreXceptionModule if preact else XceptionModule
         net_num_blocks = len(block_cfg)
         net_block_idx = 0
@@ -295,7 +300,7 @@ 
         self.feature_info += [dict(
             num_chs=self.num_features, reduction=curr_stride, module='blocks.' + str(len(self.blocks) - 1))]
-        self.act = act_layer(inplace=True) if preact else nn.Identity()
+        self.act = act_layer(inplace=True) if preact else msnn.Identity()
         self.head_hidden_size = self.num_features
         self.head = ClassifierHead(
             in_features=self.num_features,
@@ -317,7 +322,7 @@         self.grad_checkpointing = enable
 
     @torch.jit.ignore
-    def get_classifier(self) -> nn.Module:
+    def get_classifier(self) -> msnn.Cell:
         return self.head.fc
 
     def reset_classifier(self, num_classes: int, global_pool: Optional[str] = None):
@@ -336,7 +341,7 @@     def forward_head(self, x, pre_logits: bool = False):
         return self.head(x, pre_logits=pre_logits) if pre_logits else self.head(x)
 
-    def forward(self, x):
+    def construct(self, x):
         x = self.forward_features(x)
         x = self.forward_head(x)
         return x
