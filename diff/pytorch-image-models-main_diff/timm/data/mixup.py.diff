--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """ Mixup and Cutmix
 
 Papers:
@@ -11,12 +16,12 @@ Hacked together by / Copyright 2019, Ross Wightman
 """
 import numpy as np
-import torch
+# import torch
 
 
 def one_hot(x, num_classes, on_value=1., off_value=0.):
     x = x.long().view(-1, 1)
-    return torch.full((x.size()[0], num_classes), off_value, device=x.device).scatter_(1, x, on_value)
+    return mint.full((x.size()[0], num_classes), off_value, device=x.device).scatter_(1, x, on_value)
 
 
 def mixup_target(target, num_classes, lam=1., smoothing=0.0):
@@ -171,7 +176,7 @@                     lam_batch[i] = lam
                 else:
                     x[i] = x[i] * lam + x_orig[j] * (1 - lam)
-        return torch.tensor(lam_batch, device=x.device, dtype=x.dtype).unsqueeze(1)
+        return ms.Tensor(lam_batch, device=x.device, dtype=x.dtype).unsqueeze(1)
 
     def _mix_pair(self, x):
         batch_size = len(x)
@@ -191,7 +196,7 @@                     x[i] = x[i] * lam + x_orig[j] * (1 - lam)
                     x[j] = x[j] * lam + x_orig[i] * (1 - lam)
         lam_batch = np.concatenate((lam_batch, lam_batch[::-1]))
-        return torch.tensor(lam_batch, device=x.device, dtype=x.dtype).unsqueeze(1)
+        return ms.Tensor(lam_batch, device=x.device, dtype=x.dtype).unsqueeze(1)
 
     def _mix_batch(self, x):
         lam, use_cutmix = self._params_per_batch()
@@ -253,11 +258,11 @@                         np.rint(mixed, out=mixed)
                     else:
                         mixed = mixed.float() * lam + batch[j][0].float() * (1 - lam)
-                        torch.round(mixed, out=mixed)
-            output[i] += torch.from_numpy(mixed.astype(np.uint8)) if is_np else mixed.byte()
+                        ms.Tensor.round(mixed, out=mixed)
+            output[i] += torch.from_numpy(mixed.astype(np.uint8)) if is_np else mixed.byte()  # 'torch.from_numpy' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         if half:
             lam_batch = np.concatenate((lam_batch, np.ones(num_elem)))
-        return torch.tensor(lam_batch).unsqueeze(1)
+        return ms.Tensor(lam_batch).unsqueeze(1)
 
     def _mix_pair_collate(self, output, batch):
         batch_size = len(batch)
@@ -293,12 +298,12 @@                         mixed_temp = mixed_i.float() * lam + mixed_j.float() * (1 - lam)
                         mixed_j = mixed_j.float() * lam + mixed_i.float() * (1 - lam)
                         mixed_i = mixed_temp
-                        torch.round(mixed_j, out=mixed_j)
-                        torch.round(mixed_i, out=mixed_i)
-            output[i] += torch.from_numpy(mixed_i.astype(np.uint8)) if is_np else mixed_i.byte()
-            output[j] += torch.from_numpy(mixed_j.astype(np.uint8)) if is_np else mixed_j.byte()
+                        ms.Tensor.round(mixed_j, out=mixed_j)
+                        ms.Tensor.round(mixed_i, out=mixed_i)
+            output[i] += torch.from_numpy(mixed_i.astype(np.uint8)) if is_np else mixed_i.byte()  # 'torch.from_numpy' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+            output[j] += torch.from_numpy(mixed_j.astype(np.uint8)) if is_np else mixed_j.byte()  # 'torch.from_numpy' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         lam_batch = np.concatenate((lam_batch, lam_batch[::-1]))
-        return torch.tensor(lam_batch).unsqueeze(1)
+        return ms.Tensor(lam_batch).unsqueeze(1)
 
     def _mix_batch_collate(self, output, batch):
         batch_size = len(batch)
@@ -325,8 +330,8 @@                         np.rint(mixed, out=mixed)
                     else:
                         mixed = mixed.float() * lam + batch[j][0].float() * (1 - lam)
-                        torch.round(mixed, out=mixed)
-            output[i] += torch.from_numpy(mixed.astype(np.uint8)) if is_np else mixed.byte()
+                        ms.Tensor.round(mixed, out=mixed)
+            output[i] += torch.from_numpy(mixed.astype(np.uint8)) if is_np else mixed.byte()  # 'torch.from_numpy' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         return lam
 
     def __call__(self, batch, _=None):
@@ -335,14 +340,14 @@         half = 'half' in self.mode
         if half:
             batch_size //= 2
-        output = torch.zeros((batch_size, *batch[0][0].shape), dtype=torch.uint8)
+        output = mint.zeros((batch_size, *batch[0][0].shape), dtype=ms.uint8)
         if self.mode == 'elem' or self.mode == 'half':
             lam = self._mix_elem_collate(output, batch, half=half)
         elif self.mode == 'pair':
             lam = self._mix_pair_collate(output, batch)
         else:
             lam = self._mix_batch_collate(output, batch)
-        target = torch.tensor([b[1] for b in batch], dtype=torch.int64)
+        target = ms.Tensor([b[1] for b in batch], dtype=ms.int64)
         target = mixup_target(target, self.num_classes, lam, self.label_smoothing)
         target = target[:batch_size]
         return output, target
