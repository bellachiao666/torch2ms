--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """ Squeeze-and-Excitation Channel Attention
 
 An SE implementation originally based on PyTorch SE-Net impl.
@@ -12,13 +17,13 @@ """
 from typing import Optional, Tuple, Type, Union
 
-from torch import nn as nn
+# from torch import nn as nn
 
 from .create_act import create_act_layer
 from .helpers import make_divisible
 
 
-class SEModule(nn.Module):
+class SEModule(msnn.Cell):
     """ SE Module as defined in original SE-Nets with a few additions
     Additions include:
         * divisor can be specified to keep channels % div == 0 (default: 8)
@@ -35,9 +40,9 @@             rd_divisor: int = 8,
             add_maxpool: bool = False,
             bias: bool = True,
-            act_layer: Type[nn.Module] = nn.ReLU,
-            norm_layer: Optional[Type[nn.Module]] = None,
-            gate_layer: Union[str, Type[nn.Module]] = 'sigmoid',
+            act_layer: Type[msnn.Cell] = nn.ReLU,
+            norm_layer: Optional[Type[msnn.Cell]] = None,
+            gate_layer: Union[str, Type[msnn.Cell]] = 'sigmoid',
             device=None,
             dtype=None,
     ):
@@ -46,13 +51,13 @@         self.add_maxpool = add_maxpool
         if not rd_channels:
             rd_channels = make_divisible(channels * rd_ratio, rd_divisor, round_limit=0.)
-        self.fc1 = nn.Conv2d(channels, rd_channels, kernel_size=1, bias=bias, **dd)
-        self.bn = norm_layer(rd_channels, **dd) if norm_layer else nn.Identity()
+        self.fc1 = nn.Conv2d(channels, rd_channels, kernel_size=1, bias=bias, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.bn = norm_layer(rd_channels, **dd) if norm_layer else msnn.Identity()  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.act = create_act_layer(act_layer, inplace=True)
-        self.fc2 = nn.Conv2d(rd_channels, channels, kernel_size=1, bias=bias, **dd)
+        self.fc2 = nn.Conv2d(rd_channels, channels, kernel_size=1, bias=bias, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.gate = create_act_layer(gate_layer)
 
-    def forward(self, x):
+    def construct(self, x):
         x_se = x.mean((2, 3), keepdim=True)
         if self.add_maxpool:
             # experimental codepath, may remove or change
@@ -66,7 +71,7 @@ SqueezeExcite = SEModule  # alias
 
 
-class EffectiveSEModule(nn.Module):
+class EffectiveSEModule(msnn.Cell):
     """ 'Effective Squeeze-Excitation
     From `CenterMask : Real-Time Anchor-Free Instance Segmentation` - https://arxiv.org/abs/1911.06667
     """
@@ -74,7 +79,7 @@             self,
             channels: int,
             add_maxpool: bool = False,
-            gate_layer: Union[str, Type[nn.Module]] = 'hard_sigmoid',
+            gate_layer: Union[str, Type[msnn.Cell]] = 'hard_sigmoid',
             device=None,
             dtype=None,
             **_,
@@ -82,10 +87,10 @@         dd = {'device': device, 'dtype': dtype}
         super().__init__()
         self.add_maxpool = add_maxpool
-        self.fc = nn.Conv2d(channels, channels, kernel_size=1, padding=0, device=device, dtype=dtype)
+        self.fc = nn.Conv2d(channels, channels, kernel_size = 1, padding = 0, dtype = dtype)  # 'torch.nn.Conv2d':没有对应的mindspore参数 'device' (position 9);
         self.gate = create_act_layer(gate_layer)
 
-    def forward(self, x):
+    def construct(self, x):
         x_se = x.mean((2, 3), keepdim=True)
         if self.add_maxpool:
             # experimental codepath, may remove or change
@@ -97,7 +102,7 @@ EffectiveSqueezeExcite = EffectiveSEModule  # alias
 
 
-class SqueezeExciteCl(nn.Module):
+class SqueezeExciteCl(msnn.Cell):
     """ SE Module as defined in original SE-Nets with a few additions
     Additions include:
         * divisor can be specified to keep channels % div == 0 (default: 8)
@@ -113,8 +118,8 @@             rd_channels: Optional[int] = None,
             rd_divisor: int = 8,
             bias: bool = True,
-            act_layer: Type[nn.Module] = nn.ReLU,
-            gate_layer: Union[str, Type[nn.Module]] = 'sigmoid',
+            act_layer: Type[msnn.Cell] = nn.ReLU,
+            gate_layer: Union[str, Type[msnn.Cell]] = 'sigmoid',
             device=None,
             dtype=None,
     ):
@@ -122,12 +127,12 @@         super().__init__()
         if not rd_channels:
             rd_channels = make_divisible(channels * rd_ratio, rd_divisor, round_limit=0.)
-        self.fc1 = nn.Linear(channels, rd_channels, bias=bias, **dd)
+        self.fc1 = nn.Linear(channels, rd_channels, bias=bias, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.act = create_act_layer(act_layer, inplace=True)
-        self.fc2 = nn.Linear(rd_channels, channels, bias=bias, **dd)
+        self.fc2 = nn.Linear(rd_channels, channels, bias=bias, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.gate = create_act_layer(gate_layer)
 
-    def forward(self, x):
+    def construct(self, x):
         x_se = x.mean((1, 2), keepdims=True)  # FIXME avg dim [1:n-1], don't assume 2D NHWC
         x_se = self.fc1(x_se)
         x_se = self.act(x_se)
