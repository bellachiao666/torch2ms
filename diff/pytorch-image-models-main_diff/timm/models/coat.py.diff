--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """
 CoaT architecture.
 
@@ -9,9 +14,8 @@ """
 from typing import List, Optional, Tuple, Union, Type, Any
 
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
+# import torch
+# import torch.nn as nn
 
 from timm.data import IMAGENET_DEFAULT_MEAN, IMAGENET_DEFAULT_STD
 from timm.layers import PatchEmbed, Mlp, DropPath, to_2tuple, trunc_normal_, _assert, LayerNorm
@@ -21,7 +25,7 @@ __all__ = ['CoaT']
 
 
-class ConvRelPosEnc(nn.Module):
+class ConvRelPosEnc(msnn.Cell):
     """ Convolutional relative position encoding. """
     def __init__(
             self,
@@ -54,7 +58,7 @@         else:
             raise ValueError()
 
-        self.conv_list = nn.ModuleList()
+        self.conv_list = msnn.CellList()
         self.head_splits = []
         for cur_window, cur_head_split in window.items():
             dilation = 1
@@ -69,12 +73,12 @@                 dilation=(dilation, dilation),
                 groups=cur_head_split * head_chs,
                 **dd,
-            )
+            )  # 存在 *args/**kwargs，需手动确认参数映射;
             self.conv_list.append(cur_conv)
             self.head_splits.append(cur_head_split)
         self.channel_splits = [x * head_chs for x in self.head_splits]
 
-    def forward(self, q, v, size: Tuple[int, int]):
+    def construct(self, q, v, size: Tuple[int, int]):
         B, num_heads, N, C = q.shape
         H, W = size
         _assert(N == 1 + H * W, '')
@@ -84,19 +88,19 @@         v_img = v[:, :, 1:, :]  # [B, h, H*W, Ch]
 
         v_img = v_img.transpose(-1, -2).reshape(B, num_heads * C, H, W)
-        v_img_list = torch.split(v_img, self.channel_splits, dim=1)  # Split according to channels
+        v_img_list = mint.split(v_img, self.channel_splits, dim=1)  # Split according to channels
         conv_v_img_list = []
         for i, conv in enumerate(self.conv_list):
             conv_v_img_list.append(conv(v_img_list[i]))
-        conv_v_img = torch.cat(conv_v_img_list, dim=1)
+        conv_v_img = mint.cat(conv_v_img_list, dim=1)
         conv_v_img = conv_v_img.reshape(B, num_heads, C, H * W).transpose(-1, -2)
 
         EV_hat = q_img * conv_v_img
-        EV_hat = F.pad(EV_hat, (0, 0, 1, 0, 0, 0))  # [B, h, N, Ch].
+        EV_hat = nn.functional.pad(EV_hat, (0, 0, 1, 0, 0, 0))  # [B, h, N, Ch].
         return EV_hat
 
 
-class FactorAttnConvRelPosEnc(nn.Module):
+class FactorAttnConvRelPosEnc(msnn.Cell):
     """ Factorized attention with convolutional relative position encoding class. """
     def __init__(
             self,
@@ -115,15 +119,15 @@         head_dim = dim // num_heads
         self.scale = head_dim ** -0.5
 
-        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias, **dd)
+        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.attn_drop = nn.Dropout(attn_drop)  # Note: attn_drop is actually not used.
-        self.proj = nn.Linear(dim, dim, **dd)
+        self.proj = nn.Linear(dim, dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.proj_drop = nn.Dropout(proj_drop)
 
         # Shared convolutional relative position encoding.
         self.crpe = shared_crpe
 
-    def forward(self, x, size: Tuple[int, int]):
+    def construct(self, x, size: Tuple[int, int]):
         B, N, C = x.shape
 
         # Generate Q, K, V.
@@ -149,7 +153,7 @@         return x
 
 
-class ConvPosEnc(nn.Module):
+class ConvPosEnc(msnn.Cell):
     """ Convolutional Position Encoding.
         Note: This module is similar to the conditional position encoding in CPVT.
     """
@@ -162,9 +166,9 @@     ):
         dd = {'device': device, 'dtype': dtype}
         super().__init__()
-        self.proj = nn.Conv2d(dim, dim, k, 1, k//2, groups=dim, **dd)
-
-    def forward(self, x, size: Tuple[int, int]):
+        self.proj = nn.Conv2d(dim, dim, k, 1, k//2, groups=dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+
+    def construct(self, x, size: Tuple[int, int]):
         B, N, C = x.shape
         H, W = size
         _assert(N == 1 + H * W, '')
@@ -178,12 +182,12 @@         x = x.flatten(2).transpose(1, 2)
 
         # Combine with CLS token.
-        x = torch.cat((cls_token, x), dim=1)
+        x = mint.cat((cls_token, x), dim=1)
 
         return x
 
 
-class SerialBlock(nn.Module):
+class SerialBlock(msnn.Cell):
     """ Serial block class.
         Note: In this implementation, each serial block only contains a conv-attention and a FFN (MLP) module. """
     def __init__(
@@ -195,8 +199,8 @@             proj_drop: float = 0.,
             attn_drop: float = 0.,
             drop_path: float = 0.,
-            act_layer: Type[nn.Module] = nn.GELU,
-            norm_layer: Type[nn.Module] = nn.LayerNorm,
+            act_layer: Type[msnn.Cell] = nn.GELU,
+            norm_layer: Type[msnn.Cell] = nn.LayerNorm,
             shared_cpe: Optional[Any] = None,
             shared_crpe: Optional[Any] = None,
             device=None,
@@ -208,7 +212,7 @@         # Conv-Attention.
         self.cpe = shared_cpe
 
-        self.norm1 = norm_layer(dim, **dd)
+        self.norm1 = norm_layer(dim, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.factoratt_crpe = FactorAttnConvRelPosEnc(
             dim,
             num_heads=num_heads,
@@ -217,11 +221,11 @@             proj_drop=proj_drop,
             shared_crpe=shared_crpe,
             **dd,
-        )
-        self.drop_path = DropPath(drop_path) if drop_path > 0. else nn.Identity()
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.drop_path = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
 
         # MLP.
-        self.norm2 = norm_layer(dim, **dd)
+        self.norm2 = norm_layer(dim, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         mlp_hidden_dim = int(dim * mlp_ratio)
         self.mlp = Mlp(
             in_features=dim,
@@ -229,9 +233,9 @@             act_layer=act_layer,
             drop=proj_drop,
             **dd,
-        )
-
-    def forward(self, x, size: Tuple[int, int]):
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+
+    def construct(self, x, size: Tuple[int, int]):
         # Conv-Attention.
         x = self.cpe(x, size)
         cur = self.norm1(x)
@@ -246,7 +250,7 @@         return x
 
 
-class ParallelBlock(nn.Module):
+class ParallelBlock(msnn.Cell):
     """ Parallel block class. """
     def __init__(
             self,
@@ -257,8 +261,8 @@             proj_drop: float = 0.,
             attn_drop: float = 0.,
             drop_path: float = 0.,
-            act_layer: Type[nn.Module] = nn.GELU,
-            norm_layer: Type[nn.Module] = nn.LayerNorm,
+            act_layer: Type[msnn.Cell] = nn.GELU,
+            norm_layer: Type[msnn.Cell] = nn.LayerNorm,
             shared_crpes: Optional[List[Any]] = None,
             device=None,
             dtype=None,
@@ -269,9 +273,9 @@             mlp_ratios = []
 
         # Conv-Attention.
-        self.norm12 = norm_layer(dims[1], **dd)
-        self.norm13 = norm_layer(dims[2], **dd)
-        self.norm14 = norm_layer(dims[3], **dd)
+        self.norm12 = norm_layer(dims[1], **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.norm13 = norm_layer(dims[2], **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.norm14 = norm_layer(dims[3], **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.factoratt_crpe2 = FactorAttnConvRelPosEnc(
             dims[1],
             num_heads=num_heads,
@@ -280,7 +284,7 @@             proj_drop=proj_drop,
             shared_crpe=shared_crpes[1],
             **dd,
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.factoratt_crpe3 = FactorAttnConvRelPosEnc(
             dims[2],
             num_heads=num_heads,
@@ -289,7 +293,7 @@             proj_drop=proj_drop,
             shared_crpe=shared_crpes[2],
             **dd,
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.factoratt_crpe4 = FactorAttnConvRelPosEnc(
             dims[3],
             num_heads=num_heads,
@@ -298,13 +302,13 @@             proj_drop=proj_drop,
             shared_crpe=shared_crpes[3],
             **dd,
-        )
-        self.drop_path = DropPath(drop_path) if drop_path > 0. else nn.Identity()
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.drop_path = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
 
         # MLP.
-        self.norm22 = norm_layer(dims[1], **dd)
-        self.norm23 = norm_layer(dims[2], **dd)
-        self.norm24 = norm_layer(dims[3], **dd)
+        self.norm22 = norm_layer(dims[1], **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.norm23 = norm_layer(dims[2], **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.norm24 = norm_layer(dims[3], **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         # In parallel block, we assume dimensions are the same and share the linear transformation.
         assert dims[1] == dims[2] == dims[3]
         assert mlp_ratios[1] == mlp_ratios[2] == mlp_ratios[3]
@@ -315,7 +319,7 @@             act_layer=act_layer,
             drop=proj_drop,
             **dd,
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
     def upsample(self, x, factor: float, size: Tuple[int, int]):
         """ Feature map up-sampling. """
@@ -335,20 +339,15 @@         img_tokens = x[:, 1:, :]
 
         img_tokens = img_tokens.transpose(1, 2).reshape(B, C, H, W)
-        img_tokens = F.interpolate(
-            img_tokens,
-            scale_factor=scale_factor,
-            recompute_scale_factor=False,
-            mode='bilinear',
-            align_corners=False,
-        )
+        img_tokens = nn.functional.interpolate(
+            img_tokens, scale_factor = scale_factor, mode = 'bilinear', align_corners = False, recompute_scale_factor = False)
         img_tokens = img_tokens.reshape(B, C, -1).transpose(1, 2)
 
-        out = torch.cat((cls_token, img_tokens), dim=1)
+        out = mint.cat((cls_token, img_tokens), dim=1)
 
         return out
 
-    def forward(self, x1, x2, x3, x4, sizes: List[Tuple[int, int]]):
+    def construct(self, x1, x2, x3, x4, sizes: List[Tuple[int, int]]):
         _, S2, S3, S4 = sizes
         cur2 = self.norm12(x2)
         cur3 = self.norm13(x3)
@@ -383,7 +382,7 @@         return x1, x2, x3, x4
 
 
-class CoaT(nn.Module):
+class CoaT(msnn.Cell):
     """ CoaT class. """
     def __init__(
             self,
@@ -401,7 +400,7 @@             proj_drop_rate: float = 0.,
             attn_drop_rate: float = 0.,
             drop_path_rate: float = 0.,
-            norm_layer: Type[nn.Module] = LayerNorm,
+            norm_layer: Type[msnn.Cell] = LayerNorm,
             return_interm_layers: bool = False,
             out_features: Optional[List[str]] = None,
             crpe_window: Optional[dict] = None,
@@ -424,34 +423,34 @@         img_size = to_2tuple(img_size)
         self.patch_embed1 = PatchEmbed(
             img_size=img_size, patch_size=patch_size, in_chans=in_chans,
-            embed_dim=embed_dims[0], norm_layer=nn.LayerNorm, **dd)
+            embed_dim=embed_dims[0], norm_layer=nn.LayerNorm, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.patch_embed2 = PatchEmbed(
             img_size=[x // 4 for x in img_size], patch_size=2, in_chans=embed_dims[0],
-            embed_dim=embed_dims[1], norm_layer=nn.LayerNorm, **dd)
+            embed_dim=embed_dims[1], norm_layer=nn.LayerNorm, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.patch_embed3 = PatchEmbed(
             img_size=[x // 8 for x in img_size], patch_size=2, in_chans=embed_dims[1],
-            embed_dim=embed_dims[2], norm_layer=nn.LayerNorm, **dd)
+            embed_dim=embed_dims[2], norm_layer=nn.LayerNorm, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.patch_embed4 = PatchEmbed(
             img_size=[x // 16 for x in img_size], patch_size=2, in_chans=embed_dims[2],
-            embed_dim=embed_dims[3], norm_layer=nn.LayerNorm, **dd)
+            embed_dim=embed_dims[3], norm_layer=nn.LayerNorm, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         # Class tokens.
-        self.cls_token1 = nn.Parameter(torch.zeros(1, 1, embed_dims[0], **dd))
-        self.cls_token2 = nn.Parameter(torch.zeros(1, 1, embed_dims[1], **dd))
-        self.cls_token3 = nn.Parameter(torch.zeros(1, 1, embed_dims[2], **dd))
-        self.cls_token4 = nn.Parameter(torch.zeros(1, 1, embed_dims[3], **dd))
+        self.cls_token1 = ms.Parameter(mint.zeros(1, 1, embed_dims[0], **dd))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.cls_token2 = ms.Parameter(mint.zeros(1, 1, embed_dims[1], **dd))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.cls_token3 = ms.Parameter(mint.zeros(1, 1, embed_dims[2], **dd))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.cls_token4 = ms.Parameter(mint.zeros(1, 1, embed_dims[3], **dd))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         # Convolutional position encodings.
-        self.cpe1 = ConvPosEnc(dim=embed_dims[0], k=3, **dd)
-        self.cpe2 = ConvPosEnc(dim=embed_dims[1], k=3, **dd)
-        self.cpe3 = ConvPosEnc(dim=embed_dims[2], k=3, **dd)
-        self.cpe4 = ConvPosEnc(dim=embed_dims[3], k=3, **dd)
+        self.cpe1 = ConvPosEnc(dim=embed_dims[0], k=3, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.cpe2 = ConvPosEnc(dim=embed_dims[1], k=3, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.cpe3 = ConvPosEnc(dim=embed_dims[2], k=3, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.cpe4 = ConvPosEnc(dim=embed_dims[3], k=3, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         # Convolutional relative position encodings.
-        self.crpe1 = ConvRelPosEnc(head_chs=embed_dims[0] // num_heads, num_heads=num_heads, window=crpe_window, **dd)
-        self.crpe2 = ConvRelPosEnc(head_chs=embed_dims[1] // num_heads, num_heads=num_heads, window=crpe_window, **dd)
-        self.crpe3 = ConvRelPosEnc(head_chs=embed_dims[2] // num_heads, num_heads=num_heads, window=crpe_window, **dd)
-        self.crpe4 = ConvRelPosEnc(head_chs=embed_dims[3] // num_heads, num_heads=num_heads, window=crpe_window, **dd)
+        self.crpe1 = ConvRelPosEnc(head_chs=embed_dims[0] // num_heads, num_heads=num_heads, window=crpe_window, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.crpe2 = ConvRelPosEnc(head_chs=embed_dims[1] // num_heads, num_heads=num_heads, window=crpe_window, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.crpe3 = ConvRelPosEnc(head_chs=embed_dims[2] // num_heads, num_heads=num_heads, window=crpe_window, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.crpe4 = ConvRelPosEnc(head_chs=embed_dims[3] // num_heads, num_heads=num_heads, window=crpe_window, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         dpr = drop_path_rate
         skwargs = dict(
@@ -464,7 +463,7 @@         )
 
         # Serial blocks 1.
-        self.serial_blocks1 = nn.ModuleList([
+        self.serial_blocks1 = msnn.CellList([
             SerialBlock(
                 dim=embed_dims[0],
                 mlp_ratio=mlp_ratios[0],
@@ -474,10 +473,10 @@                 **dd,
             )
             for _ in range(serial_depths[0])]
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         # Serial blocks 2.
-        self.serial_blocks2 = nn.ModuleList([
+        self.serial_blocks2 = msnn.CellList([
             SerialBlock(
                 dim=embed_dims[1],
                 mlp_ratio=mlp_ratios[1],
@@ -487,10 +486,10 @@                 **dd,
             )
             for _ in range(serial_depths[1])]
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         # Serial blocks 3.
-        self.serial_blocks3 = nn.ModuleList([
+        self.serial_blocks3 = msnn.CellList([
             SerialBlock(
                 dim=embed_dims[2],
                 mlp_ratio=mlp_ratios[2],
@@ -500,10 +499,10 @@                 **dd,
             )
             for _ in range(serial_depths[2])]
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         # Serial blocks 4.
-        self.serial_blocks4 = nn.ModuleList([
+        self.serial_blocks4 = msnn.CellList([
             SerialBlock(
                 dim=embed_dims[3],
                 mlp_ratio=mlp_ratios[3],
@@ -513,12 +512,12 @@                 **dd,
             )
             for _ in range(serial_depths[3])]
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         # Parallel blocks.
         self.parallel_depth = parallel_depth
         if self.parallel_depth > 0:
-            self.parallel_blocks = nn.ModuleList([
+            self.parallel_blocks = msnn.CellList([
                 ParallelBlock(
                     dims=embed_dims,
                     mlp_ratios=mlp_ratios,
@@ -527,30 +526,30 @@                     **dd,
                 )
                 for _ in range(parallel_depth)]
-            )
+            )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         else:
             self.parallel_blocks = None
 
         # Classification head(s).
         if not self.return_interm_layers:
             if self.parallel_blocks is not None:
-                self.norm2 = norm_layer(embed_dims[1], **dd)
-                self.norm3 = norm_layer(embed_dims[2], **dd)
+                self.norm2 = norm_layer(embed_dims[1], **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+                self.norm3 = norm_layer(embed_dims[2], **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
             else:
                 self.norm2 = self.norm3 = None
-            self.norm4 = norm_layer(embed_dims[3], **dd)
+            self.norm4 = norm_layer(embed_dims[3], **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
             if self.parallel_depth > 0:
                 # CoaT series: Aggregate features of last three scales for classification.
                 assert embed_dims[1] == embed_dims[2] == embed_dims[3]
-                self.aggregate = torch.nn.Conv1d(in_channels=3, out_channels=1, kernel_size=1, **dd)
+                self.aggregate = nn.Conv1d(in_channels=3, out_channels=1, kernel_size=1, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
                 self.head_drop = nn.Dropout(drop_rate)
-                self.head = nn.Linear(self.num_features, num_classes, **dd) if num_classes > 0 else nn.Identity()
+                self.head = nn.Linear(self.num_features, num_classes, **dd) if num_classes > 0 else msnn.Identity()  # 存在 *args/**kwargs，需手动确认参数映射;
             else:
                 # CoaT-Lite series: Use feature of last scale for classification.
                 self.aggregate = None
                 self.head_drop = nn.Dropout(drop_rate)
-                self.head = nn.Linear(self.num_features, num_classes, **dd) if num_classes > 0 else nn.Identity()
+                self.head = nn.Linear(self.num_features, num_classes, **dd) if num_classes > 0 else msnn.Identity()  # 存在 *args/**kwargs，需手动确认参数映射;
 
         # Initialize weights.
         trunc_normal_(self.cls_token1, std=.02)
@@ -563,20 +562,20 @@         if isinstance(m, nn.Linear):
             trunc_normal_(m.weight, std=.02)
             if isinstance(m, nn.Linear) and m.bias is not None:
-                nn.init.constant_(m.bias, 0)
+                nn.init.constant_(m.bias, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         elif isinstance(m, nn.LayerNorm):
-            nn.init.constant_(m.bias, 0)
-            nn.init.constant_(m.weight, 1.0)
-
-    @torch.jit.ignore
+            nn.init.constant_(m.bias, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+            nn.init.constant_(m.weight, 1.0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+
+    @ms.jit
     def no_weight_decay(self):
         return {'cls_token1', 'cls_token2', 'cls_token3', 'cls_token4'}
 
-    @torch.jit.ignore
+    @ms.jit
     def set_grad_checkpointing(self, enable=True):
         assert not enable, 'gradient checkpointing not supported'
 
-    @torch.jit.ignore
+    @ms.jit
     def group_matcher(self, coarse=False):
         matcher = dict(
             stem1=r'^cls_token1|patch_embed1|crpe1|cpe1',
@@ -594,8 +593,8 @@         )
         return matcher
 
-    @torch.jit.ignore
-    def get_classifier(self) -> nn.Module:
+    @ms.jit
+    def get_classifier(self) -> msnn.Cell:
         return self.head
 
     def reset_classifier(self, num_classes: int, global_pool: Optional[str] = None):
@@ -603,7 +602,7 @@         if global_pool is not None:
             assert global_pool in ('token', 'avg')
             self.global_pool = global_pool
-        self.head = nn.Linear(self.num_features, num_classes) if num_classes > 0 else nn.Identity()
+        self.head = nn.Linear(self.num_features, num_classes) if num_classes > 0 else msnn.Identity()
 
     def forward_features(self, x0):
         B = x0.shape[0]
@@ -642,6 +641,7 @@ 
         # Only serial blocks: Early return.
         if self.parallel_blocks is None:
+            # 'torch.jit.is_scripting' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
             if not torch.jit.is_scripting() and self.return_interm_layers:
                 # Return intermediate features for down-stream tasks (e.g. Deformable DETR and Detectron2).
                 feat_out = {}
@@ -664,6 +664,7 @@             x2, x3, x4 = self.cpe2(x2, (H2, W2)), self.cpe3(x3, (H3, W3)), self.cpe4(x4, (H4, W4))
             x1, x2, x3, x4 = blk(x1, x2, x3, x4, sizes=[(H1, W1), (H2, W2), (H3, W3), (H4, W4)])
 
+        # 'torch.jit.is_scripting' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         if not torch.jit.is_scripting() and self.return_interm_layers:
             # Return intermediate features for down-stream tasks (e.g. Deformable DETR and Detectron2).
             feat_out = {}
@@ -686,20 +687,21 @@             x4 = self.norm4(x4)
             return [x2, x3, x4]
 
-    def forward_head(self, x_feat: Union[torch.Tensor, List[torch.Tensor]], pre_logits: bool = False):
+    def forward_head(self, x_feat: Union[ms.Tensor, List[ms.Tensor]], pre_logits: bool = False):
         if isinstance(x_feat, list):
             assert self.aggregate is not None
             if self.global_pool == 'avg':
-                x = torch.cat([xl[:, 1:].mean(dim=1, keepdim=True) for xl in x_feat], dim=1)  # [B, 3, C]
+                x = mint.cat([xl[:, 1:].mean(dim=1, keepdim=True) for xl in x_feat], dim=1)  # [B, 3, C]
             else:
-                x = torch.stack([xl[:, 0] for xl in x_feat], dim=1)  # [B, 3, C]
+                x = mint.stack([xl[:, 0] for xl in x_feat], dim=1)  # [B, 3, C]
             x = self.aggregate(x).squeeze(dim=1)  # Shape: [B, C]
         else:
             x = x_feat[:, 1:].mean(dim=1) if self.global_pool == 'avg' else x_feat[:, 0]
         x = self.head_drop(x)
         return x if pre_logits else self.head(x)
 
-    def forward(self, x) -> torch.Tensor:
+    def construct(self, x) -> ms.Tensor:
+        # 'torch.jit.is_scripting' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         if not torch.jit.is_scripting() and self.return_interm_layers:
             # Return intermediate features (for down-stream tasks).
             return self.forward_features(x)
@@ -713,7 +715,7 @@ def insert_cls(x, cls_token):
     """ Insert CLS token. """
     cls_tokens = cls_token.expand(x.shape[0], -1, -1)
-    x = torch.cat((cls_tokens, x), dim=1)
+    x = mint.cat((cls_tokens, x), dim=1)
     return x
 
 
@@ -748,7 +750,7 @@         pretrained,
         pretrained_filter_fn=checkpoint_filter_fn,
         **kwargs,
-    )
+    )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -783,7 +785,7 @@ def coat_tiny(pretrained=False, **kwargs) -> CoaT:
     model_cfg = dict(
         patch_size=4, embed_dims=[152, 152, 152, 152], serial_depths=[2, 2, 2, 2], parallel_depth=6)
-    model = _create_coat('coat_tiny', pretrained=pretrained, **dict(model_cfg, **kwargs))
+    model = _create_coat('coat_tiny', pretrained=pretrained, **dict(model_cfg, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -791,15 +793,15 @@ def coat_mini(pretrained=False, **kwargs) -> CoaT:
     model_cfg = dict(
         patch_size=4, embed_dims=[152, 216, 216, 216], serial_depths=[2, 2, 2, 2], parallel_depth=6)
-    model = _create_coat('coat_mini', pretrained=pretrained, **dict(model_cfg, **kwargs))
+    model = _create_coat('coat_mini', pretrained=pretrained, **dict(model_cfg, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
 @register_model
 def coat_small(pretrained=False, **kwargs) -> CoaT:
     model_cfg = dict(
-        patch_size=4, embed_dims=[152, 320, 320, 320], serial_depths=[2, 2, 2, 2], parallel_depth=6, **kwargs)
-    model = _create_coat('coat_small', pretrained=pretrained, **dict(model_cfg, **kwargs))
+        patch_size=4, embed_dims=[152, 320, 320, 320], serial_depths=[2, 2, 2, 2], parallel_depth=6, **kwargs)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+    model = _create_coat('coat_small', pretrained=pretrained, **dict(model_cfg, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -807,7 +809,7 @@ def coat_lite_tiny(pretrained=False, **kwargs) -> CoaT:
     model_cfg = dict(
         patch_size=4, embed_dims=[64, 128, 256, 320], serial_depths=[2, 2, 2, 2], mlp_ratios=[8, 8, 4, 4])
-    model = _create_coat('coat_lite_tiny', pretrained=pretrained, **dict(model_cfg, **kwargs))
+    model = _create_coat('coat_lite_tiny', pretrained=pretrained, **dict(model_cfg, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -815,7 +817,7 @@ def coat_lite_mini(pretrained=False, **kwargs) -> CoaT:
     model_cfg = dict(
         patch_size=4, embed_dims=[64, 128, 320, 512], serial_depths=[2, 2, 2, 2], mlp_ratios=[8, 8, 4, 4])
-    model = _create_coat('coat_lite_mini', pretrained=pretrained, **dict(model_cfg, **kwargs))
+    model = _create_coat('coat_lite_mini', pretrained=pretrained, **dict(model_cfg, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -823,7 +825,7 @@ def coat_lite_small(pretrained=False, **kwargs) -> CoaT:
     model_cfg = dict(
         patch_size=4, embed_dims=[64, 128, 320, 512], serial_depths=[3, 4, 6, 3], mlp_ratios=[8, 8, 4, 4])
-    model = _create_coat('coat_lite_small', pretrained=pretrained, **dict(model_cfg, **kwargs))
+    model = _create_coat('coat_lite_small', pretrained=pretrained, **dict(model_cfg, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -831,7 +833,7 @@ def coat_lite_medium(pretrained=False, **kwargs) -> CoaT:
     model_cfg = dict(
         patch_size=4, embed_dims=[128, 256, 320, 512], serial_depths=[3, 6, 10, 8])
-    model = _create_coat('coat_lite_medium', pretrained=pretrained, **dict(model_cfg, **kwargs))
+    model = _create_coat('coat_lite_medium', pretrained=pretrained, **dict(model_cfg, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -839,5 +841,5 @@ def coat_lite_medium_384(pretrained=False, **kwargs) -> CoaT:
     model_cfg = dict(
         img_size=384, patch_size=4, embed_dims=[128, 256, 320, 512], serial_depths=[3, 6, 10, 8])
-    model = _create_coat('coat_lite_medium_384', pretrained=pretrained, **dict(model_cfg, **kwargs))
+    model = _create_coat('coat_lite_medium_384', pretrained=pretrained, **dict(model_cfg, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
