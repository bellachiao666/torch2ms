--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """Patch-level random erasing augmentation for NaFlex Vision Transformers.
 
 This module implements random erasing specifically designed for patchified images,
@@ -15,7 +20,7 @@ import math
 from typing import Optional, Union, Tuple
 
-import torch
+# import torch
 
 
 class PatchRandomErasing:
@@ -26,6 +31,8 @@     2. 'region': Erases rectangular regions at patch granularity
     """
 
+    # 'torch.device' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+    # 'torch' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
     def __init__(
             self,
             erase_prob: float = 0.5,
@@ -84,13 +91,17 @@         self.const_value = value
         self.unique_noise_per_patch = True
 
+    # 'torch.Size' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+    # 'torch' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+    # 'torch.dtype' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+    # 'torch.device' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
     def _get_values(
             self,
             shape: Union[Tuple[int, ...], torch.Size],
-            value: Optional[torch.Tensor] = None,
-            dtype: torch.dtype = torch.float32,
+            value: Optional[ms.Tensor] = None,
+            dtype: torch.dtype = ms.float32,
             device: Optional[Union[str, torch.device]] = None
-    ) -> torch.Tensor:
+    ) -> ms.Tensor:
         """Generate values for erased patches based on the specified mode.
 
         Args:
@@ -105,26 +116,26 @@         device = device or self.device
         if self.erase_mode == 'pixel':
             # only mode with erase shape that includes pixels
-            return torch.empty(shape, dtype=dtype, device=device).normal_()
+            return mint.empty(shape, dtype=dtype, device=device).normal_()
         else:
             shape = (1, 1, shape[-1]) if len(shape) == 3 else (1, shape[-1])
             if self.erase_mode == 'const' or value is not None:
                 erase_value = value or self.const_value
                 if isinstance(erase_value, (int, float)):
-                    values = torch.full(shape, erase_value, dtype=dtype, device=device)
+                    values = mint.full(shape, erase_value, dtype=dtype, device=device)
                 else:
-                    erase_value = torch.tensor(erase_value, dtype=dtype, device=device)
-                    values = torch.expand_copy(erase_value, shape)
+                    erase_value = ms.Tensor(erase_value, dtype=dtype, device=device)
+                    values = torch.expand_copy(erase_value, shape)  # 'torch.expand_copy' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
             else:
-                values = torch.empty(shape, dtype=dtype, device=device).normal_()
+                values = mint.empty(shape, dtype=dtype, device=device).normal_()
             return values
 
     def _drop_patches(
             self,
-            patches: torch.Tensor,
-            patch_coord: torch.Tensor,
-            patch_valid: torch.Tensor,
-    ) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
+            patches: ms.Tensor,
+            patch_coord: ms.Tensor,
+            patch_valid: ms.Tensor,
+    ) -> Tuple[ms.Tensor, ms.Tensor, ms.Tensor]:
         """Patch Dropout.
 
         Fully drops patches from datastream. Only mode that saves compute BUT requires support
@@ -143,7 +154,7 @@             return
 
         # Get indices of valid patches
-        valid_indices = torch.nonzero(patch_valid, as_tuple=True)[0].tolist()
+        valid_indices = mint.nonzero(patch_valid, as_tuple=True)[0].tolist()
 
         # Skip if no valid patches
         if not valid_indices:
@@ -153,20 +164,23 @@         if self.patch_drop_prob:
             # patch dropout mode, completely remove dropped patches (FIXME needs downstream support in model)
             num_keep = max(1, int(num_valid * (1. - self.patch_drop_prob)))
-            keep_indices = torch.argsort(torch.randn(1, num_valid, device=self.device), dim=-1)[:, :num_keep]
+            keep_indices = mint.argsort(mint.randn(1, num_valid, device=self.device), dim=-1)[:, :num_keep]
             # maintain patch order, possibly useful for debug / visualization
             keep_indices = keep_indices.sort(dim=-1)[0]
             patches = patches.gather(1, keep_indices.unsqueeze(-1).expand((-1, -1) + patches.shape[2:]))
 
         return patches, patch_coord, patch_valid
 
+    # 'torch.Size' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+    # 'torch' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+    # 'torch.dtype' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
     def _erase_patches(
             self,
-            patches: torch.Tensor,
-            patch_coord: torch.Tensor,
-            patch_valid: torch.Tensor,
+            patches: ms.Tensor,
+            patch_coord: ms.Tensor,
+            patch_valid: ms.Tensor,
             patch_shape: torch.Size,
-            dtype: torch.dtype = torch.float32,
+            dtype: torch.dtype = ms.float32,
     ) -> None:
         """Apply erasing by selecting individual patches randomly.
 
@@ -184,7 +198,7 @@             return
 
         # Get indices of valid patches
-        valid_indices = torch.nonzero(patch_valid, as_tuple=True)[0]
+        valid_indices = mint.nonzero(patch_valid, as_tuple=True)[0]
         num_valid = len(valid_indices)
         if num_valid == 0:
             return
@@ -196,7 +210,7 @@         num_erase = random.randint(min_erase, max_erase)
 
         # Randomly select valid patches to erase
-        erase_idx = valid_indices[torch.randperm(num_valid, device=patches.device)[:num_erase]]
+        erase_idx = valid_indices[mint.randperm(num_valid, device=patches.device)[:num_erase]]
 
         if self.unique_noise_per_patch and self.erase_mode == 'pixel':
             # generate unique noise for the whole selection of patches
@@ -206,13 +220,16 @@ 
         patches[erase_idx] = self._get_values(fill_shape, dtype=dtype)
 
+    # 'torch.Size' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+    # 'torch' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+    # 'torch.dtype' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
     def _erase_region(
             self,
-            patches: torch.Tensor,
-            patch_coord: torch.Tensor,
-            patch_valid: torch.Tensor,
+            patches: ms.Tensor,
+            patch_coord: ms.Tensor,
+            patch_valid: ms.Tensor,
             patch_shape: torch.Size,
-            dtype: torch.dtype = torch.float32,
+            dtype: torch.dtype = ms.float32,
     ) -> None:
         """Apply erasing by selecting rectangular regions of patches randomly.
 
@@ -281,10 +298,10 @@ 
     def __call__(
             self,
-            patches: torch.Tensor,
-            patch_coord: torch.Tensor,
-            patch_valid: Optional[torch.Tensor] = None,
-    ) -> torch.Tensor:
+            patches: ms.Tensor,
+            patch_coord: ms.Tensor,
+            patch_valid: Optional[ms.Tensor] = None,
+    ) -> ms.Tensor:
         """Apply random patch erasing.
 
         Args:
@@ -306,7 +323,7 @@ 
         # Create default valid mask if not provided
         if patch_valid is None:
-            patch_valid = torch.ones((batch_size, num_patches), dtype=torch.bool, device=patches.device)
+            patch_valid = mint.ones((batch_size, num_patches), dtype=ms.bool_, device=patches.device)
 
         # Skip the first part of the batch if num_splits is set
         batch_start = batch_size // self.num_splits if self.num_splits > 1 else 0
