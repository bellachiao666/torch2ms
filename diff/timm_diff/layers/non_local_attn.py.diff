--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """ Bilinear-Attention-Transform and Non-Local Attention
 
 Paper: `Non-Local Neural Networks With Grouped Bilinear Attentional Transforms`
@@ -5,10 +10,8 @@ Adapted from original code: https://github.com/BA-Transform/BAT-Image-Classification
 """
 from typing import Optional, Type
-
-import torch
-from torch import nn
-from torch.nn import functional as F
+# from torch import nn
+# from torch.nn import functional as F
 
 from ._fx import register_notrace_module
 from .conv_bn_act import ConvNormAct
@@ -16,7 +19,7 @@ from .trace_utils import _assert
 
 
-class NonLocalAttn(nn.Module):
+class NonLocalAttn(msnn.Cell):
     """Spatial NL block for image classification.
 
     This was adapted from https://github.com/BA-Transform/BAT-Image-Classification
@@ -46,7 +49,7 @@         self.norm = nn.BatchNorm2d(in_channels, **dd)
         self.reset_parameters()
 
-    def forward(self, x):
+    def construct(self, x):
         shortcut = x
 
         t = self.t(x)
@@ -58,9 +61,9 @@         p = p.view(B, C, -1)
         g = g.view(B, C, -1).permute(0, 2, 1)
 
-        att = torch.bmm(t, p) * self.scale
-        att = F.softmax(att, dim=2)
-        x = torch.bmm(att, g)
+        att = mint.bmm(t, p) * self.scale
+        att = nn.functional.softmax(att, dim = 2)
+        x = mint.bmm(att, g)
 
         x = x.permute(0, 2, 1).reshape(B, C, H, W)
         x = self.z(x)
@@ -72,27 +75,27 @@         for name, m in self.named_modules():
             if isinstance(m, nn.Conv2d):
                 nn.init.kaiming_normal_(
-                    m.weight, mode='fan_out', nonlinearity='relu')
+                    m.weight, mode='fan_out', nonlinearity='relu')  # 'torch.nn.init.kaiming_normal_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
                 if len(list(m.parameters())) > 1:
-                    nn.init.constant_(m.bias, 0.0)
+                    nn.init.constant_(m.bias, 0.0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
             elif isinstance(m, nn.BatchNorm2d):
-                nn.init.constant_(m.weight, 0)
-                nn.init.constant_(m.bias, 0)
+                nn.init.constant_(m.weight, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+                nn.init.constant_(m.bias, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
             elif isinstance(m, nn.GroupNorm):
-                nn.init.constant_(m.weight, 0)
-                nn.init.constant_(m.bias, 0)
+                nn.init.constant_(m.weight, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+                nn.init.constant_(m.bias, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
 
 @register_notrace_module
-class BilinearAttnTransform(nn.Module):
+class BilinearAttnTransform(msnn.Cell):
 
     def __init__(
             self,
             in_channels: int,
             block_size: int,
             groups: int,
-            act_layer: Type[nn.Module] = nn.ReLU,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
             device=None,
             dtype=None,
     ):
@@ -112,20 +115,20 @@         if t <= 1:
             return x
         x = x.view(B * C, -1, 1, 1)
-        x = x * torch.eye(t, t, dtype=x.dtype, device=x.device)
+        x = x * mint.eye(t, t, dtype=x.dtype, device=x.device)
         x = x.view(B * C, block_size, block_size, t, t)
-        x = torch.cat(torch.split(x, 1, dim=1), dim=3)
-        x = torch.cat(torch.split(x, 1, dim=2), dim=4)
+        x = mint.cat(mint.split(x, 1, dim=1), dim=3)
+        x = mint.cat(mint.split(x, 1, dim=2), dim=4)
         x = x.view(B, C, block_size * t, block_size * t)
         return x
 
-    def forward(self, x):
+    def construct(self, x):
         _assert(x.shape[-1] % self.block_size == 0, '')
         _assert(x.shape[-2] % self.block_size == 0, '')
         B, C, H, W = x.shape
         out = self.conv1(x)
-        rp = F.adaptive_max_pool2d(out, (self.block_size, 1))
-        cp = F.adaptive_max_pool2d(out, (1, self.block_size))
+        rp = F.adaptive_max_pool2d(out, (self.block_size, 1))  # 'torch.nn.functional.adaptive_max_pool2d' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+        cp = F.adaptive_max_pool2d(out, (1, self.block_size))  # 'torch.nn.functional.adaptive_max_pool2d' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         p = self.conv_p(rp).view(B, self.groups, self.block_size, self.block_size).sigmoid()
         q = self.conv_q(cp).view(B, self.groups, self.block_size, self.block_size).sigmoid()
         p = p / p.sum(dim=3, keepdim=True)
@@ -145,7 +148,7 @@         return y
 
 
-class BatNonLocalAttn(nn.Module):
+class BatNonLocalAttn(msnn.Cell):
     """ BAT
     Adapted from: https://github.com/BA-Transform/BAT-Image-Classification
     """
@@ -159,8 +162,8 @@             rd_channels: Optional[int] = None,
             rd_divisor: int = 8,
             drop_rate: float = 0.2,
-            act_layer: Type[nn.Module] = nn.ReLU,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
             device=None,
             dtype=None,
             **_,
@@ -179,9 +182,9 @@             **dd,
         )
         self.conv2 = ConvNormAct(rd_channels, in_channels, 1, act_layer=act_layer, norm_layer=norm_layer, **dd)
-        self.dropout = nn.Dropout2d(p=drop_rate)
+        self.dropout = nn.Dropout2d(p = drop_rate)
 
-    def forward(self, x):
+    def construct(self, x):
         xl = self.conv1(x)
         y = self.ba(xl)
         y = self.conv2(y)
