--- pytorch+++ mindspore@@ -1,12 +1,14 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """ EfficientNet, MobileNetV3, etc Blocks
 
 Hacked together by / Copyright 2019, Ross Wightman
 """
 from typing import Callable, Dict, Optional, Type, Union
-
-import torch
-import torch.nn as nn
-from torch.nn import functional as F
+# import torch.nn as nn
 
 from timm.layers import (
     create_conv2d,
@@ -40,7 +42,7 @@         return channels // group_size
 
 
-class SqueezeExcite(nn.Module):
+class SqueezeExcite(msnn.Cell):
     """ Squeeze-and-Excitation w/ specific features for EfficientNet/MobileNet family
 
     Args:
@@ -75,7 +77,7 @@         self.conv_expand = nn.Conv2d(rd_channels, in_chs, 1, bias=True, **dd)
         self.gate = create_act_layer(gate_layer)
 
-    def forward(self, x):
+    def construct(self, x):
         x_se = x.mean((2, 3), keepdim=True)
         x_se = self.conv_reduce(x_se)
         x_se = self.act1(x_se)
@@ -83,7 +85,7 @@         return x * self.gate(x_se)
 
 
-class ConvBnAct(nn.Module):
+class ConvBnAct(msnn.Cell):
     """ Conv + Norm Layer + Activation w/ optional skip connection
     """
     def __init__(
@@ -122,7 +124,7 @@         )
         self.bn1 = norm_act_layer(out_chs, inplace=True, **dd)
         self.aa = create_aa(aa_layer, channels=out_chs, stride=stride, enable=use_aa, **dd)
-        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else nn.Identity()
+        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else msnn.Identity()
 
     def feature_info(self, location):
         if location == 'expansion':  # output of conv after act, same as block coutput
@@ -130,7 +132,7 @@         else:  # location == 'bottleneck', block output
             return dict(module='', num_chs=self.conv.out_channels)
 
-    def forward(self, x):
+    def construct(self, x):
         shortcut = x
         x = self.conv(x)
         x = self.bn1(x)
@@ -140,7 +142,7 @@         return x
 
 
-class DepthwiseSeparableConv(nn.Module):
+class DepthwiseSeparableConv(msnn.Cell):
     """ Depthwise-separable block
     Used for DS convs in MobileNet-V1 and in the place of IR blocks that have no expansion
     (factor of 1.0). This is an alternative to having a IR with an optional first pw conv.
@@ -203,11 +205,11 @@         self.aa = create_aa(aa_layer, channels=out_chs, stride=stride, enable=use_aa, **dd)
 
         # Squeeze-and-excitation
-        self.se = se_layer(in_chs, act_layer=act_layer, **dd) if se_layer else nn.Identity()
+        self.se = se_layer(in_chs, act_layer=act_layer, **dd) if se_layer else msnn.Identity()
 
         self.conv_pw = create_conv2d(in_chs, out_chs, pw_kernel_size, padding=pad_type, **dd)
         self.bn2 = norm_act_layer(out_chs, inplace=True, apply_act=self.has_pw_act, **dd)
-        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else nn.Identity()
+        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else msnn.Identity()
 
     def feature_info(self, location):
         if location == 'expansion':  # after SE, input to PW
@@ -215,7 +217,7 @@         else:  # location == 'bottleneck', block output
             return dict(module='', num_chs=self.conv_pw.out_channels)
 
-    def forward(self, x):
+    def construct(self, x):
         shortcut = x
         if self.conv_s2d is not None:
             x = self.conv_s2d(x)
@@ -231,7 +233,7 @@         return x
 
 
-class InvertedResidual(nn.Module):
+class InvertedResidual(msnn.Cell):
     """ Inverted residual block w/ optional SE
 
     Originally used in MobileNet-V2 - https://arxiv.org/abs/1801.04381v4, this layer is often
@@ -308,12 +310,12 @@         self.aa = create_aa(aa_layer, channels=mid_chs, stride=stride, enable=use_aa, **dd)
 
         # Squeeze-and-excitation
-        self.se = se_layer(mid_chs, act_layer=act_layer, **dd) if se_layer else nn.Identity()
+        self.se = se_layer(mid_chs, act_layer=act_layer, **dd) if se_layer else msnn.Identity()
 
         # Point-wise linear projection
         self.conv_pwl = create_conv2d(mid_chs, out_chs, pw_kernel_size, padding=pad_type, **conv_kwargs, **dd)
         self.bn3 = norm_act_layer(out_chs, apply_act=False, **dd)
-        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else nn.Identity()
+        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else msnn.Identity()
 
     def feature_info(self, location):
         if location == 'expansion':  # after SE, input to PWL
@@ -321,7 +323,7 @@         else:  # location == 'bottleneck', block output
             return dict(module='', num_chs=self.conv_pwl.out_channels)
 
-    def forward(self, x):
+    def construct(self, x):
         shortcut = x
         if self.conv_s2d is not None:
             x = self.conv_s2d(x)
@@ -339,7 +341,7 @@         return x
 
 
-class UniversalInvertedResidual(nn.Module):
+class UniversalInvertedResidual(msnn.Cell):
     """ Universal Inverted Residual Block (aka Universal Inverted Bottleneck, UIB)
 
     For MobileNetV4 - https://arxiv.org/abs/, referenced from
@@ -394,7 +396,7 @@                 **dd,
             )
         else:
-            self.dw_start = nn.Identity()
+            self.dw_start = msnn.Identity()
 
         # Point-wise expansion
         mid_chs = make_divisible(in_chs * exp_ratio)
@@ -424,10 +426,10 @@             )
         else:
             # keeping mid as identity so it can be hooked more easily for features
-            self.dw_mid = nn.Identity()
+            self.dw_mid = msnn.Identity()
 
         # Squeeze-and-excitation
-        self.se = se_layer(mid_chs, act_layer=act_layer, **dd) if se_layer else nn.Identity()
+        self.se = se_layer(mid_chs, act_layer=act_layer, **dd) if se_layer else msnn.Identity()
 
         # Point-wise linear projection
         self.pw_proj = ConvNormAct(
@@ -458,13 +460,13 @@                 **dd,
             )
         else:
-            self.dw_end = nn.Identity()
+            self.dw_end = msnn.Identity()
 
         if layer_scale_init_value is not None:
             self.layer_scale = LayerScale2d(out_chs, layer_scale_init_value, **dd)
         else:
-            self.layer_scale = nn.Identity()
-        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else nn.Identity()
+            self.layer_scale = msnn.Identity()
+        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else msnn.Identity()
 
     def feature_info(self, location):
         if location == 'expansion':  # after SE, input to PWL
@@ -472,7 +474,7 @@         else:  # location == 'bottleneck', block output
             return dict(module='', num_chs=self.pw_proj.conv.out_channels)
 
-    def forward(self, x):
+    def construct(self, x):
         shortcut = x
         x = self.dw_start(x)
         x = self.pw_exp(x)
@@ -486,7 +488,7 @@         return x
 
 
-class MobileAttention(nn.Module):
+class MobileAttention(msnn.Cell):
     """ Mobile Attention Block
 
     For MobileNetV4 - https://arxiv.org/abs/, referenced from
@@ -584,9 +586,9 @@         if layer_scale_init_value is not None:
             self.layer_scale = LayerScale2d(out_chs, layer_scale_init_value, **dd)
         else:
-            self.layer_scale = nn.Identity()
-
-        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else nn.Identity()
+            self.layer_scale = msnn.Identity()
+
+        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else msnn.Identity()
 
     def feature_info(self, location):
         if location == 'expansion':  # after SE, input to PW
@@ -594,7 +596,7 @@         else:  # location == 'bottleneck', block output
             return dict(module='', num_chs=self.conv_pw.out_channels)
 
-    def forward(self, x):
+    def construct(self, x):
         if self.conv_cpe_dw is not None:
             x_cpe = self.conv_cpe_dw(x)
             x = x + x_cpe
@@ -661,8 +663,8 @@ 
     def forward(self, x):
         shortcut = x
-        pooled_inputs = F.adaptive_avg_pool2d(x, 1).flatten(1)  # CondConv routing
-        routing_weights = torch.sigmoid(self.routing_fn(pooled_inputs))
+        pooled_inputs = ms.Tensor.flatten(1)  # CondConv routing
+        routing_weights = mint.sigmoid(self.routing_fn(pooled_inputs))
         x = self.conv_pw(x, routing_weights)
         x = self.bn1(x)
         x = self.conv_dw(x, routing_weights)
@@ -675,7 +677,7 @@         return x
 
 
-class EdgeResidual(nn.Module):
+class EdgeResidual(msnn.Cell):
     """ Residual block with expansion convolution followed by pointwise-linear w/ stride
 
     Originally introduced in `EfficientNet-EdgeTPU: Creating Accelerator-Optimized Neural Networks with AutoML`
@@ -735,12 +737,12 @@         self.aa = create_aa(aa_layer, channels=mid_chs, stride=stride, enable=use_aa, **dd)
 
         # Squeeze-and-excitation
-        self.se = se_layer(mid_chs, act_layer=act_layer, **dd) if se_layer else nn.Identity()
+        self.se = se_layer(mid_chs, act_layer=act_layer, **dd) if se_layer else msnn.Identity()
 
         # Point-wise linear projection
         self.conv_pwl = create_conv2d(mid_chs, out_chs, pw_kernel_size, padding=pad_type, **dd)
         self.bn2 = norm_act_layer(out_chs, apply_act=False, **dd)
-        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else nn.Identity()
+        self.drop_path = DropPath(drop_path_rate) if drop_path_rate else msnn.Identity()
 
     def feature_info(self, location):
         if location == 'expansion':  # after SE, before PWL
@@ -748,7 +750,7 @@         else:  # location == 'bottleneck', block output
             return dict(module='', num_chs=self.conv_pwl.out_channels)
 
-    def forward(self, x):
+    def construct(self, x):
         shortcut = x
         x = self.conv_exp(x)
         x = self.bn1(x)
