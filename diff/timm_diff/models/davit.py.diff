--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """ DaViT: Dual Attention Vision Transformers
 
 As described in https://arxiv.org/abs/2204.03645
@@ -14,10 +19,10 @@ from functools import partial
 from typing import List, Optional, Tuple, Type, Union
 
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
-from torch import Tensor
+# import torch
+# import torch.nn as nn
+# import torch.nn.functional as F
+# from torch import Tensor
 
 from timm.data import IMAGENET_DEFAULT_MEAN, IMAGENET_DEFAULT_STD
 from timm.layers import DropPath, calculate_drop_path_rates, to_2tuple, trunc_normal_, Mlp, LayerNorm2d, get_norm_layer, use_fused_attn
@@ -31,7 +36,7 @@ __all__ = ['DaVit']
 
 
-class ConvPosEnc(nn.Module):
+class ConvPosEnc(msnn.Cell):
     def __init__(
             self,
             dim: int,
@@ -52,15 +57,15 @@             groups=dim,
             **dd,
         )
-        self.act = nn.GELU() if act else nn.Identity()
-
-    def forward(self, x: Tensor):
+        self.act = nn.GELU() if act else msnn.Identity()
+
+    def construct(self, x: ms.Tensor):
         feat = self.proj(x)
         x = x + self.act(feat)
         return x
 
 
-class Stem(nn.Module):
+class Stem(msnn.Cell):
     """ Size-agnostic implementation of 2D image to patch embedding,
         allowing input size to be adjusted during model forward operation
     """
@@ -70,7 +75,7 @@             in_chs: int = 3,
             out_chs: int = 96,
             stride: int = 4,
-            norm_layer: Type[nn.Module] = LayerNorm2d,
+            norm_layer: Type[msnn.Cell] = LayerNorm2d,
             device=None,
             dtype=None,
     ):
@@ -91,23 +96,23 @@         )
         self.norm = norm_layer(out_chs, **dd)
 
-    def forward(self, x: Tensor):
+    def construct(self, x: ms.Tensor):
         B, C, H, W = x.shape
         pad_r = (self.stride[1] - W % self.stride[1]) % self.stride[1]
         pad_b = (self.stride[0] - H % self.stride[0]) % self.stride[0]
-        x = F.pad(x, (0, pad_r, 0, pad_b))
+        x = nn.functional.pad(x, (0, pad_r, 0, pad_b))
         x = self.conv(x)
         x = self.norm(x)
         return x
 
 
-class Downsample(nn.Module):
+class Downsample(msnn.Cell):
     def __init__(
             self,
             in_chs: int,
             out_chs: int,
             kernel_size: int = 3,
-            norm_layer: Type[nn.Module] = LayerNorm2d,
+            norm_layer: Type[msnn.Cell] = LayerNorm2d,
             device=None,
             dtype=None,
     ):
@@ -127,19 +132,19 @@             **dd,
         )
 
-    def forward(self, x: Tensor):
+    def construct(self, x: ms.Tensor):
         B, C, H, W = x.shape
         x = self.norm(x)
         if self.even_k:
             k_h, k_w = self.conv.kernel_size
             pad_r = (k_w - W % k_w) % k_w
             pad_b = (k_h - H % k_h) % k_h
-            x = F.pad(x, (0, pad_r , 0, pad_b))
+            x = nn.functional.pad(x, (0, pad_r , 0, pad_b))
         x = self.conv(x)
         return x
 
 
-class ChannelAttentionV2(nn.Module):
+class ChannelAttentionV2(msnn.Cell):
 
     def __init__(
             self,
@@ -159,7 +164,7 @@         self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias, **dd)
         self.proj = nn.Linear(dim, dim, **dd)
 
-    def forward(self, x):
+    def construct(self, x):
         B, N, C = x.shape
 
         qkv = self.qkv(x).reshape(B, N, 3, self.groups, C // self.groups).permute(2, 0, 3, 1, 4)
@@ -179,7 +184,7 @@ 
 
 
-class ChannelAttention(nn.Module):
+class ChannelAttention(msnn.Cell):
 
     def __init__(
             self,
@@ -198,7 +203,7 @@         self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias, **dd)
         self.proj = nn.Linear(dim, dim, **dd)
 
-    def forward(self, x: Tensor):
+    def construct(self, x: ms.Tensor):
         B, N, C = x.shape
 
         qkv = self.qkv(x).reshape(B, N, 3, self.num_heads, C // self.num_heads).permute(2, 0, 3, 1, 4)
@@ -213,7 +218,7 @@         return x
 
 
-class ChannelBlock(nn.Module):
+class ChannelBlock(msnn.Cell):
 
     def __init__(
             self,
@@ -222,8 +227,8 @@             mlp_ratio: float = 4.,
             qkv_bias: bool = False,
             drop_path: float = 0.,
-            act_layer: Type[nn.Module] = nn.GELU,
-            norm_layer: Type[nn.Module] = nn.LayerNorm,
+            act_layer: Type[msnn.Cell] = nn.GELU,
+            norm_layer: Type[msnn.Cell] = nn.LayerNorm,
             ffn: bool = True,
             cpe_act: bool = False,
             v2: bool = False,
@@ -243,7 +248,7 @@             qkv_bias=qkv_bias,
             **dd,
         )
-        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
+        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
         self.cpe2 = ConvPosEnc(dim=dim, k=3, act=cpe_act, **dd)
 
         if self.ffn:
@@ -254,13 +259,13 @@                 act_layer=act_layer,
                 **dd,
             )
-            self.drop_path2 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
+            self.drop_path2 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
         else:
             self.norm2 = None
             self.mlp = None
             self.drop_path2 = None
 
-    def forward(self, x: Tensor):
+    def construct(self, x: ms.Tensor):
         B, C, H, W = x.shape
 
         x = self.cpe1(x).flatten(2).transpose(1, 2)
@@ -279,7 +284,7 @@         return x
 
 
-def window_partition(x: Tensor, window_size: Tuple[int, int]):
+def window_partition(x: ms.Tensor, window_size: Tuple[int, int]):
     """
     Args:
         x: (B, H, W, C)
@@ -294,7 +299,7 @@ 
 
 @register_notrace_function  # reason: int argument is a Proxy
-def window_reverse(windows: Tensor, window_size: Tuple[int, int], H: int, W: int):
+def window_reverse(windows: ms.Tensor, window_size: Tuple[int, int], H: int, W: int):
     """
     Args:
         windows: (num_windows*B, window_size, window_size, C)
@@ -310,7 +315,7 @@     return x
 
 
-class WindowAttention(nn.Module):
+class WindowAttention(msnn.Cell):
     r""" Window based multi-head self attention (W-MSA) module with relative position bias.
     It supports both of shifted and non-shifted window.
     Args:
@@ -342,16 +347,16 @@         self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias, **dd)
         self.proj = nn.Linear(dim, dim, **dd)
 
-        self.softmax = nn.Softmax(dim=-1)
-
-    def forward(self, x: Tensor):
+        self.softmax = nn.Softmax(dim = -1)
+
+    def construct(self, x: ms.Tensor):
         B_, N, C = x.shape
 
         qkv = self.qkv(x).reshape(B_, N, 3, self.num_heads, C // self.num_heads).permute(2, 0, 3, 1, 4)
         q, k, v = qkv.unbind(0)
 
         if self.fused_attn:
-            x = F.scaled_dot_product_attention(q, k, v)
+            x = F.scaled_dot_product_attention(q, k, v)  # 'torch.nn.functional.scaled_dot_product_attention' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         else:
             q = q * self.scale
             attn = (q @ k.transpose(-2, -1))
@@ -363,7 +368,7 @@         return x
 
 
-class SpatialBlock(nn.Module):
+class SpatialBlock(msnn.Cell):
     r""" Windows Block.
     Args:
         dim (int): Number of input channels.
@@ -384,8 +389,8 @@             mlp_ratio: float = 4.,
             qkv_bias: bool = True,
             drop_path: float = 0.,
-            act_layer: Type[nn.Module] = nn.GELU,
-            norm_layer: Type[nn.Module] = nn.LayerNorm,
+            act_layer: Type[msnn.Cell] = nn.GELU,
+            norm_layer: Type[msnn.Cell] = nn.LayerNorm,
             ffn: bool = True,
             cpe_act: bool = False,
             device=None,
@@ -408,7 +413,7 @@             qkv_bias=qkv_bias,
             **dd,
         )
-        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
+        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
 
         self.cpe2 = ConvPosEnc(dim=dim, k=3, act=cpe_act, **dd)
         if self.ffn:
@@ -420,13 +425,13 @@                 act_layer=act_layer,
                 **dd,
             )
-            self.drop_path2 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
+            self.drop_path2 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
         else:
             self.norm2 = None
             self.mlp = None
             self.drop_path1 = None
 
-    def forward(self, x: Tensor):
+    def construct(self, x: ms.Tensor):
         B, C, H, W = x.shape
 
         shortcut = self.cpe1(x).flatten(2).transpose(1, 2)
@@ -437,7 +442,7 @@         pad_l = pad_t = 0
         pad_r = (self.window_size[1] - W % self.window_size[1]) % self.window_size[1]
         pad_b = (self.window_size[0] - H % self.window_size[0]) % self.window_size[0]
-        x = F.pad(x, (0, 0, pad_l, pad_r, pad_t, pad_b))
+        x = nn.functional.pad(x, (0, 0, pad_l, pad_r, pad_t, pad_b))
         _, Hp, Wp, _ = x.shape
 
         x_windows = window_partition(x, self.window_size)
@@ -466,7 +471,7 @@         return x
 
 
-class DaVitStage(nn.Module):
+class DaVitStage(msnn.Cell):
     def __init__(
             self,
             in_chs: int,
@@ -479,8 +484,8 @@             mlp_ratio: float = 4.,
             qkv_bias: bool = True,
             drop_path_rates: Tuple[float, ...] = (0, 0),
-            norm_layer: Type[nn.Module] = LayerNorm2d,
-            norm_layer_cl: Type[nn.Module] = nn.LayerNorm,
+            norm_layer: Type[msnn.Cell] = LayerNorm2d,
+            norm_layer_cl: Type[msnn.Cell] = nn.LayerNorm,
             ffn: bool = True,
             cpe_act: bool = False,
             down_kernel_size: int = 2,
@@ -498,7 +503,7 @@         if downsample:
             self.downsample = Downsample(in_chs, out_chs, kernel_size=down_kernel_size, norm_layer=norm_layer, **dd)
         else:
-            self.downsample = nn.Identity()
+            self.downsample = msnn.Identity()
 
         '''
          repeating alternating attention blocks in each stage
@@ -539,16 +544,22 @@                         **dd,
                     )))
             if named_blocks:
-                stage_blocks.append(nn.Sequential(OrderedDict(dual_attention_block)))
+                stage_blocks.append(msnn.SequentialCell([
+                    OrderedDict(dual_attention_block)
+                ]))
             else:
-                stage_blocks.append(nn.Sequential(*[b[1] for b in dual_attention_block]))
-        self.blocks = nn.Sequential(*stage_blocks)
+                stage_blocks.append(msnn.SequentialCell([
+                    [b[1] for b in dual_attention_block]
+                ]))
+        self.blocks = msnn.SequentialCell([
+            stage_blocks
+        ])
 
     @torch.jit.ignore
     def set_grad_checkpointing(self, enable=True):
         self.grad_checkpointing = enable
 
-    def forward(self, x: Tensor):
+    def construct(self, x: ms.Tensor):
         x = self.downsample(x)
         if self.grad_checkpointing and not torch.jit.is_scripting():
             x = checkpoint_seq(self.blocks, x)
@@ -557,7 +568,7 @@         return x
 
 
-class DaVit(nn.Module):
+class DaVit(msnn.Cell):
     r""" DaViT
         A PyTorch implementation of `DaViT: Dual Attention Vision Transformers`  - https://arxiv.org/abs/2204.03645
         Supports arbitrary input sizes and pyramid feature extraction
@@ -644,7 +655,9 @@             stages.append(stage)
             self.feature_info += [dict(num_chs=out_chs, reduction=2**(i+2), module=f'stages.{i}')]
 
-        self.stages = nn.Sequential(*stages)
+        self.stages = msnn.SequentialCell([
+            stages
+        ])
 
         # if head_norm_first == true, norm -> global pool -> fc ordering, like most other nets
         # otherwise pool -> norm -> fc, the default DaViT order, similar to ConvNeXt
@@ -659,7 +672,7 @@                 **dd,
             )
         else:
-            self.norm_pre = nn.Identity()
+            self.norm_pre = msnn.Identity()
             self.head = NormMlpClassifierHead(
                 self.num_features,
                 num_classes,
@@ -674,7 +687,7 @@         if isinstance(m, nn.Linear):
             trunc_normal_(m.weight, std=.02)
             if isinstance(m, nn.Linear) and m.bias is not None:
-                nn.init.constant_(m.bias, 0)
+                nn.init.constant_(m.bias, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
     @torch.jit.ignore
     def group_matcher(self, coarse=False):
@@ -694,7 +707,7 @@             stage.set_grad_checkpointing(enable=enable)
 
     @torch.jit.ignore
-    def get_classifier(self) -> nn.Module:
+    def get_classifier(self) -> msnn.Cell:
         return self.head.fc
 
     def reset_classifier(self, num_classes: int, global_pool: Optional[str] = None):
@@ -703,13 +716,13 @@ 
     def forward_intermediates(
             self,
-            x: torch.Tensor,
+            x: ms.Tensor,
             indices: Optional[Union[int, List[int]]] = None,
             norm: bool = False,
             stop_early: bool = False,
             output_fmt: str = 'NCHW',
             intermediates_only: bool = False,
-    ) -> Union[List[torch.Tensor], Tuple[torch.Tensor, List[torch.Tensor]]]:
+    ) -> Union[List[ms.Tensor], Tuple[ms.Tensor, List[ms.Tensor]]]:
         """ Forward features that returns intermediates.
 
         Args:
@@ -765,7 +778,7 @@         take_indices, max_index = feature_take_indices(len(self.stages), indices)
         self.stages = self.stages[:max_index + 1]  # truncate blocks w/ stem as idx 0
         if prune_norm:
-            self.norm_pre = nn.Identity()
+            self.norm_pre = msnn.Identity()
         if prune_head:
             self.reset_classifier(0, '')
         return take_indices
@@ -782,7 +795,7 @@     def forward_head(self, x, pre_logits: bool = False):
         return self.head(x, pre_logits=True) if pre_logits else self.head(x)
 
-    def forward(self, x):
+    def construct(self, x):
         x = self.forward_features(x)
         x = self.forward_head(x)
         return x
