--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """ Next-ViT
 
 As described in https://arxiv.org/abs/2207.05501
@@ -8,9 +13,9 @@ from functools import partial
 from typing import List, Optional, Tuple, Union, Type
 
-import torch
-import torch.nn.functional as F
-from torch import nn
+# import torch
+# import torch.nn.functional as F
+# from torch import nn
 
 from timm.data import IMAGENET_DEFAULT_MEAN, IMAGENET_DEFAULT_STD
 from timm.layers import DropPath, calculate_drop_path_rates, trunc_normal_, ConvMlp, get_norm_layer, get_act_layer, use_fused_attn
@@ -28,8 +33,8 @@     """
     weight = module.weight.data
     if module.bias is None:
-        zeros = torch.zeros(module.out_chs, device=weight.device).type(weight.type())
-        module.bias = nn.Parameter(zeros)
+        zeros = mint.zeros(module.out_chs, device=weight.device).type(weight.type())
+        module.bias = ms.Parameter(zeros)
     bias = module.bias.data
     if pre_bn_2 is None:
         assert pre_bn_1.track_running_stats is True, "Unsupported bn_module.track_running_stats is False"
@@ -70,7 +75,7 @@     module.bias.data = bias
 
 
-class ConvNormAct(nn.Module):
+class ConvNormAct(msnn.Cell):
     def __init__(
             self,
             in_chs: int,
@@ -78,8 +83,8 @@             kernel_size: int = 3,
             stride: int = 1,
             groups: int = 1,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
-            act_layer: Type[nn.Module] = nn.ReLU,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
             device=None,
             dtype=None,
     ):
@@ -94,11 +99,11 @@             groups=groups,
             bias=False,
             **dd,
-        )
-        self.norm = norm_layer(out_chs, **dd)
+        )  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.norm = norm_layer(out_chs, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.act = act_layer()
 
-    def forward(self, x):
+    def construct(self, x):
         x = self.conv(x)
         x = self.norm(x)
         x = self.act(x)
@@ -115,36 +120,36 @@     return new_v
 
 
-class PatchEmbed(nn.Module):
+class PatchEmbed(msnn.Cell):
     def __init__(
             self,
             in_chs: int,
             out_chs: int,
             stride: int = 1,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
             device=None,
             dtype=None,
     ):
         dd = {'device': device, 'dtype': dtype}
         super().__init__()
         if stride == 2:
-            self.pool = nn.AvgPool2d((2, 2), stride=2, ceil_mode=True, count_include_pad=False)
-            self.conv = nn.Conv2d(in_chs, out_chs, kernel_size=1, stride=1, bias=False, **dd)
-            self.norm = norm_layer(out_chs, **dd)
+            self.pool = nn.AvgPool2d((2, 2), stride = 2, ceil_mode = True, count_include_pad = False)
+            self.conv = nn.Conv2d(in_chs, out_chs, kernel_size=1, stride=1, bias=False, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+            self.norm = norm_layer(out_chs, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         elif in_chs != out_chs:
-            self.pool = nn.Identity()
-            self.conv = nn.Conv2d(in_chs, out_chs, kernel_size=1, stride=1, bias=False, **dd)
-            self.norm = norm_layer(out_chs, **dd)
+            self.pool = msnn.Identity()
+            self.conv = nn.Conv2d(in_chs, out_chs, kernel_size=1, stride=1, bias=False, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+            self.norm = norm_layer(out_chs, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         else:
-            self.pool = nn.Identity()
-            self.conv = nn.Identity()
-            self.norm = nn.Identity()
-
-    def forward(self, x):
+            self.pool = msnn.Identity()
+            self.conv = msnn.Identity()
+            self.norm = msnn.Identity()
+
+    def construct(self, x):
         return self.norm(self.conv(self.pool(x)))
 
 
-class ConvAttention(nn.Module):
+class ConvAttention(msnn.Cell):
     """
     Multi-Head Convolutional Attention
     """
@@ -153,8 +158,8 @@             self,
             out_chs: int,
             head_dim: int,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
-            act_layer: Type[nn.Module] = nn.ReLU,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
             device=None,
             dtype=None,
     ):
@@ -169,19 +174,19 @@             groups=out_chs // head_dim,
             bias=False,
             **dd,
-        )
-        self.norm = norm_layer(out_chs, **dd)
+        )  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.norm = norm_layer(out_chs, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.act = act_layer()
-        self.projection = nn.Conv2d(out_chs, out_chs, kernel_size=1, bias=False, **dd)
-
-    def forward(self, x):
+        self.projection = nn.Conv2d(out_chs, out_chs, kernel_size=1, bias=False, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+
+    def construct(self, x):
         out = self.group_conv3x3(x)
         out = self.norm(out)
         out = self.act(out)
         out = self.projection(out)
         return out
 
-class NextConvBlock(nn.Module):
+class NextConvBlock(msnn.Cell):
     """
     Next Convolution Block
     """
@@ -195,8 +200,8 @@             drop: float = 0.,
             head_dim: int = 32,
             mlp_ratio: float = 3.,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
-            act_layer: Type[nn.Module] = nn.ReLU,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
             device=None,
             dtype=None,
     ):
@@ -206,17 +211,17 @@         self.out_chs = out_chs
         assert out_chs % head_dim == 0
 
-        self.patch_embed = PatchEmbed(in_chs, out_chs, stride, norm_layer=norm_layer, **dd)
+        self.patch_embed = PatchEmbed(in_chs, out_chs, stride, norm_layer=norm_layer, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.mhca = ConvAttention(
             out_chs,
             head_dim,
             norm_layer=norm_layer,
             act_layer=act_layer,
             **dd,
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.attn_drop_path = DropPath(drop_path)
 
-        self.norm = norm_layer(out_chs, **dd)
+        self.norm = norm_layer(out_chs, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.mlp = ConvMlp(
             out_chs,
             hidden_features=int(out_chs * mlp_ratio),
@@ -224,7 +229,7 @@             bias=True,
             act_layer=act_layer,
             **dd,
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.mlp_drop_path = DropPath(drop_path)
         self.is_fused = False
 
@@ -232,10 +237,10 @@     def reparameterize(self):
         if not self.is_fused:
             merge_pre_bn(self.mlp.fc1, self.norm)
-            self.norm = nn.Identity()
+            self.norm = msnn.Identity()
             self.is_fused = True
 
-    def forward(self, x):
+    def construct(self, x):
         x = self.patch_embed(x)
         x = x + self.attn_drop_path(self.mhca(x))
 
@@ -244,11 +249,11 @@         return x
 
 
-class EfficientAttention(nn.Module):
+class EfficientAttention(msnn.Cell):
     """
     Efficient Multi-Head Self Attention
     """
-    fused_attn: torch.jit.Final[bool]
+    fused_attn: torch.jit.Final[bool]  # 'torch.jit.Final' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
     def __init__(
             self,
@@ -259,7 +264,7 @@             attn_drop: float = 0.,
             proj_drop: float = 0.,
             sr_ratio: int = 1,
-            norm_layer: Type[nn.Module] = nn.BatchNorm1d,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm1d,
             device=None,
             dtype=None,
     ):
@@ -272,23 +277,23 @@         self.scale = head_dim ** -0.5
         self.fused_attn = use_fused_attn()
 
-        self.q = nn.Linear(dim, self.dim, bias=qkv_bias, **dd)
-        self.k = nn.Linear(dim, self.dim, bias=qkv_bias, **dd)
-        self.v = nn.Linear(dim, self.dim, bias=qkv_bias, **dd)
-        self.proj = nn.Linear(self.dim, self.out_dim, **dd)
+        self.q = nn.Linear(dim, self.dim, bias=qkv_bias, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.k = nn.Linear(dim, self.dim, bias=qkv_bias, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.v = nn.Linear(dim, self.dim, bias=qkv_bias, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.proj = nn.Linear(self.dim, self.out_dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.attn_drop = nn.Dropout(attn_drop)
         self.proj_drop = nn.Dropout(proj_drop)
 
         self.sr_ratio = sr_ratio
         self.N_ratio = sr_ratio ** 2
         if sr_ratio > 1:
-            self.sr = nn.AvgPool1d(kernel_size=self.N_ratio, stride=self.N_ratio)
-            self.norm = norm_layer(dim, **dd)
+            self.sr = nn.AvgPool1d(kernel_size=self.N_ratio, stride=self.N_ratio)  # 'torch.nn.AvgPool1d' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+            self.norm = norm_layer(dim, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         else:
             self.sr = None
             self.norm = None
 
-    def forward(self, x):
+    def construct(self, x):
         B, N, C = x.shape
         q = self.q(x).reshape(B, N, self.num_heads, self.head_dim).permute(0, 2, 1, 3)
 
@@ -303,7 +308,7 @@             x = F.scaled_dot_product_attention(
                 q, k, v,
                 dropout_p=self.attn_drop.p if self.training else 0.,
-            )
+            )  # 'torch.nn.functional.scaled_dot_product_attention' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         else:
             q = q * self.scale
             attn = q @ k.transpose(-1, -2)
@@ -317,7 +322,7 @@         return x
 
 
-class NextTransformerBlock(nn.Module):
+class NextTransformerBlock(msnn.Cell):
     """
     Next Transformer Block
     """
@@ -334,8 +339,8 @@             mix_block_ratio: float = 0.75,
             attn_drop: float = 0.,
             drop: float = 0.,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
-            act_layer: Type[nn.Module] = nn.ReLU,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
             device=None,
             dtype=None,
     ):
@@ -348,8 +353,8 @@         self.mhsa_out_chs = _make_divisible(int(out_chs * mix_block_ratio), 32)
         self.mhca_out_chs = out_chs - self.mhsa_out_chs
 
-        self.patch_embed = PatchEmbed(in_chs, self.mhsa_out_chs, stride, **dd)
-        self.norm1 = norm_layer(self.mhsa_out_chs, **dd)
+        self.patch_embed = PatchEmbed(in_chs, self.mhsa_out_chs, stride, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.norm1 = norm_layer(self.mhsa_out_chs, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.e_mhsa = EfficientAttention(
             self.mhsa_out_chs,
             head_dim=head_dim,
@@ -357,7 +362,7 @@             attn_drop=attn_drop,
             proj_drop=drop,
             **dd,
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.mhsa_drop_path = DropPath(drop_path * mix_block_ratio)
 
         self.projection = PatchEmbed(
@@ -366,24 +371,24 @@             stride=1,
             norm_layer=norm_layer,
             **dd,
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.mhca = ConvAttention(
             self.mhca_out_chs,
             head_dim=head_dim,
             norm_layer=norm_layer,
             act_layer=act_layer,
             **dd,
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.mhca_drop_path = DropPath(drop_path * (1 - mix_block_ratio))
 
-        self.norm2 = norm_layer(out_chs, **dd)
+        self.norm2 = norm_layer(out_chs, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.mlp = ConvMlp(
             out_chs,
             hidden_features=int(out_chs * mlp_ratio),
             act_layer=act_layer,
             drop=drop,
             **dd,
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.mlp_drop_path = DropPath(drop_path)
         self.is_fused = False
 
@@ -394,17 +399,17 @@             if self.e_mhsa.norm is not None:
                 merge_pre_bn(self.e_mhsa.k, self.norm1, self.e_mhsa.norm)
                 merge_pre_bn(self.e_mhsa.v, self.norm1, self.e_mhsa.norm)
-                self.e_mhsa.norm = nn.Identity()
+                self.e_mhsa.norm = msnn.Identity()
             else:
                 merge_pre_bn(self.e_mhsa.k, self.norm1)
                 merge_pre_bn(self.e_mhsa.v, self.norm1)
-            self.norm1 = nn.Identity()
+            self.norm1 = msnn.Identity()
 
             merge_pre_bn(self.mlp.fc1, self.norm2)
-            self.norm2 = nn.Identity()
+            self.norm2 = msnn.Identity()
             self.is_fused = True
 
-    def forward(self, x):
+    def construct(self, x):
         x = self.patch_embed(x)
         B, C, H, W = x.shape
 
@@ -415,20 +420,20 @@ 
         out = self.projection(x)
         out = out + self.mhca_drop_path(self.mhca(out))
-        x = torch.cat([x, out], dim=1)
+        x = mint.cat([x, out], dim=1)
 
         out = self.norm2(x)
         x = x + self.mlp_drop_path(self.mlp(out))
         return x
 
 
-class NextStage(nn.Module):
+class NextStage(msnn.Cell):
 
     def __init__(
             self,
             in_chs: int,
             block_chs: List[int],
-            block_types: List[Type[nn.Module]],
+            block_types: List[Type[msnn.Cell]],
             stride: int = 2,
             sr_ratio: int = 1,
             mix_block_ratio: float = 1.0,
@@ -436,8 +441,8 @@             attn_drop: float = 0.,
             drop_path: Union[float, List[float], Tuple[float, ...]] = 0.,
             head_dim: int = 32,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
-            act_layer: Type[nn.Module] = nn.ReLU,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
+            act_layer: Type[msnn.Cell] = nn.ReLU,
             device=None,
             dtype=None,
     ):
@@ -462,7 +467,7 @@                     norm_layer=norm_layer,
                     act_layer=act_layer,
                     **dd,
-                )
+                )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
                 blocks.append(layer)
             elif block_type is NextTransformerBlock:
                 layer = NextTransformerBlock(
@@ -478,17 +483,17 @@                     norm_layer=norm_layer,
                     act_layer=act_layer,
                     **dd,
-                )
+                )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
                 blocks.append(layer)
             in_chs = out_chs
 
-        self.blocks = nn.Sequential(*blocks)
-
-    @torch.jit.ignore
+        self.blocks = msnn.SequentialCell(*blocks)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+
+    @ms.jit
     def set_grad_checkpointing(self, enable=True):
         self.grad_checkpointing = enable
 
-    def forward(self, x):
+    def construct(self, x):
         if self.grad_checkpointing and not torch.jit.is_scripting():
             x = checkpoint_seq(self.blocks, x)
         else:
@@ -496,7 +501,7 @@         return x
 
 
-class NextViT(nn.Module):
+class NextViT(msnn.Cell):
     def __init__(
             self,
             in_chans: int,
@@ -511,8 +516,8 @@             drop_rate: float = 0.,
             head_dim: int = 32,
             mix_block_ratio: float = 0.75,
-            norm_layer: Type[nn.Module] = nn.BatchNorm2d,
-            act_layer: Optional[Type[nn.Module]] = None,
+            norm_layer: Type[msnn.Cell] = nn.BatchNorm2d,
+            act_layer: Optional[Type[msnn.Cell]] = None,
             device=None,
             dtype=None,
     ):
@@ -545,7 +550,7 @@             [NextConvBlock, NextConvBlock, NextConvBlock, NextConvBlock, NextTransformerBlock] * (depths[2] // 5),
             [NextConvBlock] * (depths[3] - 1) + [NextTransformerBlock]]
 
-        self.stem = nn.Sequential(
+        self.stem = msnn.SequentialCell(
             ConvNormAct(
                 in_chans, stem_chs[0], kernel_size=3, stride=2, norm_layer=norm_layer, act_layer=act_layer, **dd),
             ConvNormAct(
@@ -554,7 +559,7 @@                 stem_chs[1], stem_chs[2], kernel_size=3, stride=1, norm_layer=norm_layer, act_layer=act_layer, **dd),
             ConvNormAct(
                 stem_chs[2], stem_chs[2], kernel_size=3, stride=2, norm_layer=norm_layer, act_layer=act_layer, **dd),
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         in_chs = out_chs = stem_chs[-1]
         stages = []
         idx = 0
@@ -574,14 +579,14 @@                 norm_layer=norm_layer,
                 act_layer=act_layer,
                 **dd,
-            )
+            )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
             in_chs = out_chs = self.stage_out_chs[stage_idx][-1]
             stages += [stage]
             idx += depths[stage_idx]
         self.num_features = self.head_hidden_size = out_chs
-        self.stages = nn.Sequential(*stages)
-        self.norm = norm_layer(out_chs, **dd)
-        self.head = ClassifierHead(pool_type=global_pool, in_features=out_chs, num_classes=num_classes, **dd)
+        self.stages = msnn.SequentialCell(*stages)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.norm = norm_layer(out_chs, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.head = ClassifierHead(pool_type=global_pool, in_features=out_chs, num_classes=num_classes, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         self.stage_out_idx = [sum(depths[:idx + 1]) - 1 for idx in range(len(depths))]
         self._initialize_weights()
@@ -591,13 +596,13 @@             if isinstance(m, nn.Linear):
                 trunc_normal_(m.weight, std=.02)
                 if hasattr(m, 'bias') and m.bias is not None:
-                    nn.init.constant_(m.bias, 0)
+                    nn.init.constant_(m.bias, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
             elif isinstance(m, nn.Conv2d):
                 trunc_normal_(m.weight, std=.02)
                 if hasattr(m, 'bias') and m.bias is not None:
-                    nn.init.constant_(m.bias, 0)
-
-    @torch.jit.ignore
+                    nn.init.constant_(m.bias, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+
+    @ms.jit
     def group_matcher(self, coarse=False):
         return dict(
             stem=r'^stem',  # stem and embed
@@ -607,14 +612,14 @@             ]
         )
 
-    @torch.jit.ignore
+    @ms.jit
     def set_grad_checkpointing(self, enable=True):
         self.grad_checkpointing = enable
         for stage in self.stages:
             stage.set_grad_checkpointing(enable=enable)
 
-    @torch.jit.ignore
-    def get_classifier(self) -> nn.Module:
+    @ms.jit
+    def get_classifier(self) -> msnn.Cell:
         return self.head.fc
 
     def reset_classifier(self, num_classes: int, global_pool: Optional[str] = None):
@@ -623,13 +628,13 @@ 
     def forward_intermediates(
             self,
-            x: torch.Tensor,
+            x: ms.Tensor,
             indices: Optional[Union[int, List[int]]] = None,
             norm: bool = False,
             stop_early: bool = False,
             output_fmt: str = 'NCHW',
             intermediates_only: bool = False,
-    ) -> Union[List[torch.Tensor], Tuple[torch.Tensor, List[torch.Tensor]]]:
+    ) -> Union[List[ms.Tensor], Tuple[ms.Tensor, List[ms.Tensor]]]:
         """ Forward features that returns intermediates.
 
         Args:
@@ -685,7 +690,7 @@         take_indices, max_index = feature_take_indices(len(self.stages), indices)
         self.stages = self.stages[:max_index + 1]  # truncate blocks w/ stem as idx 0
         if prune_norm:
-            self.norm = nn.Identity()
+            self.norm = msnn.Identity()
         if prune_head:
             self.reset_classifier(0, '')
         return take_indices
@@ -702,7 +707,7 @@     def forward_head(self, x, pre_logits: bool = False):
         return self.head(x, pre_logits=pre_logits) if pre_logits else self.head(x)
 
-    def forward(self, x):
+    def construct(self, x):
         x = self.forward_features(x)
         x = self.forward_head(x)
         return x
@@ -732,7 +737,7 @@         pretrained,
         pretrained_filter_fn=checkpoint_filter_fn,
         feature_cfg=dict(flatten_sequential=True, out_indices=out_indices),
-        **kwargs)
+        **kwargs)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
     return model
 
@@ -800,7 +805,7 @@ def nextvit_small(pretrained=False, **kwargs):
     model_args = dict(depths=(3, 4, 10, 3), drop_path_rate=0.1)
     model = _create_nextvit(
-        'nextvit_small', pretrained=pretrained, **dict(model_args, **kwargs))
+        'nextvit_small', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -808,7 +813,7 @@ def nextvit_base(pretrained=False, **kwargs):
     model_args = dict(depths=(3, 4, 20, 3), drop_path_rate=0.2)
     model = _create_nextvit(
-        'nextvit_base', pretrained=pretrained, **dict(model_args, **kwargs))
+        'nextvit_base', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -816,5 +821,5 @@ def nextvit_large(pretrained=False, **kwargs):
     model_args = dict(depths=(3, 4, 30, 3), drop_path_rate=0.2)
     model = _create_nextvit(
-        'nextvit_large', pretrained=pretrained, **dict(model_args, **kwargs))
+        'nextvit_large', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
