--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """ Pyramid Vision Transformer v2
 
 @misc{wang2021pvtv2,
@@ -18,9 +23,9 @@ import math
 from typing import Callable, List, Optional, Tuple, Union, Type, Any
 
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
+# import torch
+# import torch.nn as nn
+# import torch.nn.functional as F
 
 from timm.data import IMAGENET_DEFAULT_MEAN, IMAGENET_DEFAULT_STD
 from timm.layers import DropPath, calculate_drop_path_rates, to_2tuple, to_ntuple, trunc_normal_, LayerNorm, use_fused_attn
@@ -32,13 +37,13 @@ __all__ = ['PyramidVisionTransformerV2']
 
 
-class MlpWithDepthwiseConv(nn.Module):
+class MlpWithDepthwiseConv(msnn.Cell):
     def __init__(
             self,
             in_features: int,
             hidden_features: Optional[int] = None,
             out_features: Optional[int] = None,
-            act_layer: Type[nn.Module] = nn.GELU,
+            act_layer: Type[msnn.Cell] = nn.GELU,
             drop: float = 0.,
             extra_relu: bool = False,
             device=None,
@@ -48,14 +53,14 @@         dd = {'device': device, 'dtype': dtype}
         out_features = out_features or in_features
         hidden_features = hidden_features or in_features
-        self.fc1 = nn.Linear(in_features, hidden_features, **dd)
-        self.relu = nn.ReLU() if extra_relu else nn.Identity()
-        self.dwconv = nn.Conv2d(hidden_features, hidden_features, 3, 1, 1, bias=True, groups=hidden_features, **dd)
+        self.fc1 = nn.Linear(in_features, hidden_features, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.relu = nn.ReLU() if extra_relu else msnn.Identity()
+        self.dwconv = nn.Conv2d(hidden_features, hidden_features, 3, 1, 1, bias=True, groups=hidden_features, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.act = act_layer()
-        self.fc2 = nn.Linear(hidden_features, out_features, **dd)
+        self.fc2 = nn.Linear(hidden_features, out_features, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.drop = nn.Dropout(drop)
 
-    def forward(self, x, feat_size: List[int]):
+    def construct(self, x, feat_size: List[int]):
         x = self.fc1(x)
         B, N, C = x.shape
         x = x.transpose(1, 2).view(B, C, feat_size[0], feat_size[1])
@@ -69,8 +74,8 @@         return x
 
 
-class Attention(nn.Module):
-    fused_attn: torch.jit.Final[bool]
+class Attention(msnn.Cell):
+    fused_attn: torch.jit.Final[bool]  # 'torch.jit.Final' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
     def __init__(
             self,
@@ -94,28 +99,28 @@         self.scale = self.head_dim ** -0.5
         self.fused_attn = use_fused_attn()
 
-        self.q = nn.Linear(dim, dim, bias=qkv_bias, **dd)
-        self.kv = nn.Linear(dim, dim * 2, bias=qkv_bias, **dd)
+        self.q = nn.Linear(dim, dim, bias=qkv_bias, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.kv = nn.Linear(dim, dim * 2, bias=qkv_bias, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.attn_drop = nn.Dropout(attn_drop)
-        self.proj = nn.Linear(dim, dim, **dd)
+        self.proj = nn.Linear(dim, dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.proj_drop = nn.Dropout(proj_drop)
 
         if not linear_attn:
             self.pool = None
             if sr_ratio > 1:
-                self.sr = nn.Conv2d(dim, dim, kernel_size=sr_ratio, stride=sr_ratio, **dd)
-                self.norm = nn.LayerNorm(dim, **dd)
+                self.sr = nn.Conv2d(dim, dim, kernel_size=sr_ratio, stride=sr_ratio, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+                self.norm = nn.LayerNorm(dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
             else:
                 self.sr = None
                 self.norm = None
             self.act = None
         else:
             self.pool = nn.AdaptiveAvgPool2d(7)
-            self.sr = nn.Conv2d(dim, dim, kernel_size=1, stride=1, **dd)
-            self.norm = nn.LayerNorm(dim, **dd)
+            self.sr = nn.Conv2d(dim, dim, kernel_size=1, stride=1, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+            self.norm = nn.LayerNorm(dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
             self.act = nn.GELU()
 
-    def forward(self, x, feat_size: List[int]):
+    def construct(self, x, feat_size: List[int]):
         B, N, C = x.shape
         H, W = feat_size
         q = self.q(x).reshape(B, N, self.num_heads, -1).permute(0, 2, 1, 3)
@@ -137,7 +142,7 @@         k, v = kv.unbind(0)
 
         if self.fused_attn:
-            x = F.scaled_dot_product_attention(q, k, v, dropout_p=self.attn_drop.p if self.training else 0.)
+            x = F.scaled_dot_product_attention(q, k, v, dropout_p=self.attn_drop.p if self.training else 0.)  # 'torch.nn.functional.scaled_dot_product_attention' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         else:
             q = q * self.scale
             attn = q @ k.transpose(-2, -1)
@@ -151,7 +156,7 @@         return x
 
 
-class Block(nn.Module):
+class Block(msnn.Cell):
 
     def __init__(
             self,
@@ -164,14 +169,14 @@             proj_drop: float = 0.,
             attn_drop: float = 0.,
             drop_path: float = 0.,
-            act_layer: Type[nn.Module] = nn.GELU,
-            norm_layer: Type[nn.Module] = LayerNorm,
+            act_layer: Type[msnn.Cell] = nn.GELU,
+            norm_layer: Type[msnn.Cell] = LayerNorm,
             device=None,
             dtype=None,
     ):
         super().__init__()
         dd = {'device': device, 'dtype': dtype}
-        self.norm1 = norm_layer(dim, **dd)
+        self.norm1 = norm_layer(dim, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.attn = Attention(
             dim,
             num_heads=num_heads,
@@ -181,10 +186,10 @@             attn_drop=attn_drop,
             proj_drop=proj_drop,
             **dd,
-        )
-        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
-
-        self.norm2 = norm_layer(dim, **dd)
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
+
+        self.norm2 = norm_layer(dim, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.mlp = MlpWithDepthwiseConv(
             in_features=dim,
             hidden_features=int(dim * mlp_ratio),
@@ -192,17 +197,17 @@             drop=proj_drop,
             extra_relu=linear_attn,
             **dd,
-        )
-        self.drop_path2 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
-
-    def forward(self, x, feat_size: List[int]):
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.drop_path2 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
+
+    def construct(self, x, feat_size: List[int]):
         x = x + self.drop_path1(self.attn(self.norm1(x), feat_size))
         x = x + self.drop_path2(self.mlp(self.norm2(x), feat_size))
 
         return x
 
 
-class OverlapPatchEmbed(nn.Module):
+class OverlapPatchEmbed(msnn.Cell):
     """ Image to Patch Embedding
     """
     def __init__(
@@ -221,17 +226,17 @@         self.patch_size = patch_size
         self.proj = nn.Conv2d(
             in_chans, embed_dim, patch_size,
-            stride=stride, padding=(patch_size[0] // 2, patch_size[1] // 2), **dd)
-        self.norm = nn.LayerNorm(embed_dim, **dd)
-
-    def forward(self, x):
+            stride=stride, padding=(patch_size[0] // 2, patch_size[1] // 2), **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.norm = nn.LayerNorm(embed_dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+
+    def construct(self, x):
         x = self.proj(x)
         x = x.permute(0, 2, 3, 1)
         x = self.norm(x)
         return x
 
 
-class PyramidVisionTransformerStage(nn.Module):
+class PyramidVisionTransformerStage(msnn.Cell):
     def __init__(
             self,
             dim: int,
@@ -261,12 +266,12 @@                 in_chans=dim,
                 embed_dim=dim_out,
                 **dd,
-            )
+            )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         else:
             assert dim == dim_out
             self.downsample = None
 
-        self.blocks = nn.ModuleList([Block(
+        self.blocks = msnn.CellList([Block(
             dim=dim_out,
             num_heads=num_heads,
             sr_ratio=sr_ratio,
@@ -278,11 +283,11 @@             drop_path=drop_path[i] if isinstance(drop_path, list) else drop_path,
             norm_layer=norm_layer,
             **dd,
-        ) for i in range(depth)])
-
-        self.norm = norm_layer(dim_out, **dd)
-
-    def forward(self, x):
+        ) for i in range(depth)])  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+
+        self.norm = norm_layer(dim_out, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+
+    def construct(self, x):
         # x is either B, C, H, W (if downsample) or B, H, W, C if not
         if self.downsample is not None:
             # input to downsample is B, C, H, W
@@ -300,7 +305,7 @@         return x
 
 
-class PyramidVisionTransformerV2(nn.Module):
+class PyramidVisionTransformerV2(msnn.Cell):
     def __init__(
             self,
             in_chans: int = 3,
@@ -317,7 +322,7 @@             proj_drop_rate: float = 0.,
             attn_drop_rate: float = 0.,
             drop_path_rate: float = 0.,
-            norm_layer: Type[nn.Module] = LayerNorm,
+            norm_layer: Type[msnn.Cell] = LayerNorm,
             device=None,
             dtype=None,
     ):
@@ -340,7 +345,7 @@             in_chans=in_chans,
             embed_dim=embed_dims[0],
             **dd,
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         dpr = calculate_drop_path_rates(drop_path_rate, depths, stagewise=True)
         cur = 0
@@ -362,16 +367,16 @@                 drop_path=dpr[i],
                 norm_layer=norm_layer,
                 **dd,
-            )]
+            )]  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
             prev_dim = embed_dims[i]
             cur += depths[i]
             self.feature_info += [dict(num_chs=prev_dim, reduction=4 * 2**i, module=f'stages.{i}')]
-        self.stages = nn.Sequential(*stages)
+        self.stages = msnn.SequentialCell(*stages)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         # classification head
         self.num_features = self.head_hidden_size = embed_dims[-1]
         self.head_drop = nn.Dropout(drop_rate)
-        self.head = nn.Linear(embed_dims[-1], num_classes, **dd) if num_classes > 0 else nn.Identity()
+        self.head = nn.Linear(embed_dims[-1], num_classes, **dd) if num_classes > 0 else msnn.Identity()  # 存在 *args/**kwargs，需手动确认参数映射;
 
         self.apply(self._init_weights)
 
@@ -379,7 +384,7 @@         if isinstance(m, nn.Linear):
             trunc_normal_(m.weight, std=.02)
             if isinstance(m, nn.Linear) and m.bias is not None:
-                nn.init.constant_(m.bias, 0)
+                nn.init.constant_(m.bias, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         elif isinstance(m, nn.Conv2d):
             fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
             fan_out //= m.groups
@@ -390,11 +395,11 @@     def freeze_patch_emb(self):
         self.patch_embed.requires_grad = False
 
-    @torch.jit.ignore
+    @ms.jit
     def no_weight_decay(self):
         return {}
 
-    @torch.jit.ignore
+    @ms.jit
     def group_matcher(self, coarse=False):
         matcher = dict(
             stem=r'^patch_embed',  # stem and embed
@@ -402,12 +407,12 @@         )
         return matcher
 
-    @torch.jit.ignore
+    @ms.jit
     def set_grad_checkpointing(self, enable=True):
         for s in self.stages:
             s.grad_checkpointing = enable
 
-    def get_classifier(self) -> nn.Module:
+    def get_classifier(self) -> msnn.Cell:
         return self.head
 
     def reset_classifier(self, num_classes: int, global_pool: Optional[str] = None):
@@ -417,17 +422,17 @@             self.global_pool = global_pool
         device = self.head.weight.device if hasattr(self.head, 'weight') else None
         dtype = self.head.weight.dtype if hasattr(self.head, 'weight') else None
-        self.head = nn.Linear(self.num_features, num_classes, device=device, dtype=dtype) if num_classes > 0 else nn.Identity()
+        self.head = nn.Linear(self.num_features, num_classes, dtype = dtype) if num_classes > 0 else msnn.Identity()  # 'torch.nn.Linear':没有对应的mindspore参数 'device' (position 3);
 
     def forward_intermediates(
             self,
-            x: torch.Tensor,
+            x: ms.Tensor,
             indices: Optional[Union[int, List[int]]] = None,
             norm: bool = False,
             stop_early: bool = False,
             output_fmt: str = 'NCHW',
             intermediates_only: bool = False,
-    ) -> Union[List[torch.Tensor], Tuple[torch.Tensor, List[torch.Tensor]]]:
+    ) -> Union[List[ms.Tensor], Tuple[ms.Tensor, List[ms.Tensor]]]:
         """ Forward features that returns intermediates.
 
         Args:
@@ -486,7 +491,7 @@         x = self.head_drop(x)
         return x if pre_logits else self.head(x)
 
-    def forward(self, x):
+    def construct(self, x):
         x = self.forward_features(x)
         x = self.forward_head(x)
         return x
@@ -522,7 +527,7 @@         pretrained_filter_fn=checkpoint_filter_fn,
         feature_cfg=dict(flatten_sequential=True, out_indices=out_indices),
         **kwargs,
-    )
+    )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -551,43 +556,43 @@ @register_model
 def pvt_v2_b0(pretrained=False, **kwargs) -> PyramidVisionTransformerV2:
     model_args = dict(depths=(2, 2, 2, 2), embed_dims=(32, 64, 160, 256), num_heads=(1, 2, 5, 8))
-    return _create_pvt2('pvt_v2_b0', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_pvt2('pvt_v2_b0', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
 
 @register_model
 def pvt_v2_b1(pretrained=False, **kwargs) -> PyramidVisionTransformerV2:
     model_args = dict(depths=(2, 2, 2, 2), embed_dims=(64, 128, 320, 512), num_heads=(1, 2, 5, 8))
-    return _create_pvt2('pvt_v2_b1', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_pvt2('pvt_v2_b1', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
 
 @register_model
 def pvt_v2_b2(pretrained=False, **kwargs) -> PyramidVisionTransformerV2:
     model_args = dict(depths=(3, 4, 6, 3), embed_dims=(64, 128, 320, 512), num_heads=(1, 2, 5, 8))
-    return _create_pvt2('pvt_v2_b2', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_pvt2('pvt_v2_b2', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
 
 @register_model
 def pvt_v2_b3(pretrained=False, **kwargs) -> PyramidVisionTransformerV2:
     model_args = dict(depths=(3, 4, 18, 3), embed_dims=(64, 128, 320, 512), num_heads=(1, 2, 5, 8))
-    return _create_pvt2('pvt_v2_b3', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_pvt2('pvt_v2_b3', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
 
 @register_model
 def pvt_v2_b4(pretrained=False, **kwargs) -> PyramidVisionTransformerV2:
     model_args = dict(depths=(3, 8, 27, 3), embed_dims=(64, 128, 320, 512), num_heads=(1, 2, 5, 8))
-    return _create_pvt2('pvt_v2_b4', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_pvt2('pvt_v2_b4', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
 
 @register_model
 def pvt_v2_b5(pretrained=False, **kwargs) -> PyramidVisionTransformerV2:
     model_args = dict(
         depths=(3, 6, 40, 3), embed_dims=(64, 128, 320, 512), num_heads=(1, 2, 5, 8), mlp_ratios=(4, 4, 4, 4))
-    return _create_pvt2('pvt_v2_b5', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_pvt2('pvt_v2_b5', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
 
 @register_model
 def pvt_v2_b2_li(pretrained=False, **kwargs) -> PyramidVisionTransformerV2:
     model_args = dict(
         depths=(3, 4, 6, 3), embed_dims=(64, 128, 320, 512), num_heads=(1, 2, 5, 8), linear=True)
-    return _create_pvt2('pvt_v2_b2_li', pretrained=pretrained, **dict(model_args, **kwargs))
-
+    return _create_pvt2('pvt_v2_b2_li', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+
