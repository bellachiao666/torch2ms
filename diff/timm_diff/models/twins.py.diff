--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """ Twins
 A PyTorch impl of : `Twins: Revisiting the Design of Spatial Attention in Vision Transformers`
     - https://arxiv.org/pdf/2104.13840.pdf
@@ -15,9 +20,9 @@ from functools import partial
 from typing import List, Optional, Tuple, Union, Type, Any
 
-import torch
-import torch.nn as nn
-import torch.nn.functional as F
+# import torch
+# import torch.nn as nn
+# import torch.nn.functional as F
 
 from timm.data import IMAGENET_DEFAULT_MEAN, IMAGENET_DEFAULT_STD
 from timm.layers import Mlp, DropPath, to_2tuple, trunc_normal_, use_fused_attn, calculate_drop_path_rates
@@ -33,10 +38,10 @@ 
 
 @register_notrace_module  # reason: FX can't symbolically trace control flow in forward method
-class LocallyGroupedAttn(nn.Module):
+class LocallyGroupedAttn(msnn.Cell):
     """ LSA: self attention within a group
     """
-    fused_attn: torch.jit.Final[bool]
+    fused_attn: torch.jit.Final[bool]  # 'torch.jit.Final' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
     def __init__(
             self,
@@ -59,13 +64,13 @@         self.scale = head_dim ** -0.5
         self.fused_attn = use_fused_attn()
 
-        self.qkv = nn.Linear(dim, dim * 3, bias=True, **dd)
+        self.qkv = nn.Linear(dim, dim * 3, bias=True, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.attn_drop = nn.Dropout(attn_drop)
-        self.proj = nn.Linear(dim, dim, **dd)
+        self.proj = nn.Linear(dim, dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.proj_drop = nn.Dropout(proj_drop)
         self.ws = ws
 
-    def forward(self, x, size: Size_):
+    def construct(self, x, size: Size_):
         # There are two implementations for this function, zero padding or mask. We don't observe obvious difference for
         # both. You can choose any one, we recommend forward_padding because it's neat. However,
         # the masking implementation is more reasonable and accurate.
@@ -75,7 +80,7 @@         pad_l = pad_t = 0
         pad_r = (self.ws - W % self.ws) % self.ws
         pad_b = (self.ws - H % self.ws) % self.ws
-        x = F.pad(x, (0, 0, pad_l, pad_r, pad_t, pad_b))
+        x = nn.functional.pad(x, (0, 0, pad_l, pad_r, pad_t, pad_b))
         _, Hp, Wp, _ = x.shape
         _h, _w = Hp // self.ws, Wp // self.ws
         x = x.reshape(B, _h, self.ws, _w, self.ws, C).transpose(2, 3)
@@ -87,7 +92,7 @@             x = F.scaled_dot_product_attention(
                 q, k, v,
                 dropout_p=self.attn_drop.p if self.training else 0.,
-            )
+            )  # 'torch.nn.functional.scaled_dot_product_attention' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         else:
             q = q * self.scale
             attn = q @ k.transpose(-2, -1)
@@ -140,10 +145,10 @@     #     return x
 
 
-class GlobalSubSampleAttn(nn.Module):
+class GlobalSubSampleAttn(msnn.Cell):
     """ GSA: using a  key to summarize the information for a group to be efficient.
     """
-    fused_attn: torch.jit.Final[bool]
+    fused_attn: torch.jit.Final[bool]  # 'torch.jit.Final' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
     def __init__(
             self,
@@ -165,26 +170,26 @@         self.scale = head_dim ** -0.5
         self.fused_attn = use_fused_attn()
 
-        self.q = nn.Linear(dim, dim, bias=True, **dd)
-        self.kv = nn.Linear(dim, dim * 2, bias=True, **dd)
+        self.q = nn.Linear(dim, dim, bias=True, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.kv = nn.Linear(dim, dim * 2, bias=True, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.attn_drop = nn.Dropout(attn_drop)
-        self.proj = nn.Linear(dim, dim, **dd)
+        self.proj = nn.Linear(dim, dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.proj_drop = nn.Dropout(proj_drop)
 
         self.sr_ratio = sr_ratio
         if sr_ratio > 1:
-            self.sr = nn.Conv2d(dim, dim, kernel_size=sr_ratio, stride=sr_ratio, **dd)
-            self.norm = nn.LayerNorm(dim, **dd)
+            self.sr = nn.Conv2d(dim, dim, kernel_size=sr_ratio, stride=sr_ratio, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+            self.norm = nn.LayerNorm(dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         else:
             self.sr = None
             self.norm = None
 
-    def forward(self, x, size: Size_):
+    def construct(self, x, size: Size_):
         B, N, C = x.shape
         q = self.q(x).reshape(B, N, self.num_heads, C // self.num_heads).permute(0, 2, 1, 3)
 
         if self.sr is not None:
-            x = x.permute(0, 2, 1).reshape(B, C, *size)
+            x = x.permute(0, 2, 1).reshape(B, C, *size)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
             x = self.sr(x).reshape(B, C, -1).permute(0, 2, 1)
             x = self.norm(x)
         kv = self.kv(x).reshape(B, -1, 2, self.num_heads, C // self.num_heads).permute(2, 0, 3, 1, 4)
@@ -194,7 +199,7 @@             x = torch.nn.functional.scaled_dot_product_attention(
                 q, k, v,
                 dropout_p=self.attn_drop.p if self.training else 0.,
-            )
+            )  # 'torch.nn.functional.scaled_dot_product_attention' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         else:
             q = q * self.scale
             attn = q @ k.transpose(-2, -1)
@@ -209,7 +214,7 @@         return x
 
 
-class Block(nn.Module):
+class Block(msnn.Cell):
 
     def __init__(
             self,
@@ -219,8 +224,8 @@             proj_drop: float = 0.,
             attn_drop: float = 0.,
             drop_path: float = 0.,
-            act_layer: Type[nn.Module] = nn.GELU,
-            norm_layer: Type[nn.Module] = nn.LayerNorm,
+            act_layer: Type[msnn.Cell] = nn.GELU,
+            norm_layer: Type[msnn.Cell] = nn.LayerNorm,
             sr_ratio: int = 1,
             ws: Optional[int] = None,
             device=None,
@@ -228,32 +233,32 @@     ):
         super().__init__()
         dd = {'device': device, 'dtype': dtype}
-        self.norm1 = norm_layer(dim, **dd)
+        self.norm1 = norm_layer(dim, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         if ws is None:
-            self.attn = Attention(dim, num_heads, False, None, attn_drop, proj_drop, **dd)
+            self.attn = Attention(dim, num_heads, False, None, attn_drop, proj_drop, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         elif ws == 1:
-            self.attn = GlobalSubSampleAttn(dim, num_heads, attn_drop, proj_drop, sr_ratio, **dd)
+            self.attn = GlobalSubSampleAttn(dim, num_heads, attn_drop, proj_drop, sr_ratio, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         else:
-            self.attn = LocallyGroupedAttn(dim, num_heads, attn_drop, proj_drop, ws, **dd)
-        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
-
-        self.norm2 = norm_layer(dim, **dd)
+            self.attn = LocallyGroupedAttn(dim, num_heads, attn_drop, proj_drop, ws, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
+
+        self.norm2 = norm_layer(dim, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.mlp = Mlp(
             in_features=dim,
             hidden_features=int(dim * mlp_ratio),
             act_layer=act_layer,
             drop=proj_drop,
             **dd,
-        )
-        self.drop_path2 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
-
-    def forward(self, x, size: Size_):
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.drop_path2 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
+
+    def construct(self, x, size: Size_):
         x = x + self.drop_path1(self.attn(self.norm1(x), size))
         x = x + self.drop_path2(self.mlp(self.norm2(x)))
         return x
 
 
-class PosConv(nn.Module):
+class PosConv(msnn.Cell):
     # PEG  from https://arxiv.org/abs/2102.10882
     def __init__(
             self,
@@ -265,14 +270,15 @@     ):
         dd = {'device': device, 'dtype': dtype}
         super().__init__()
-        self.proj = nn.Sequential(
-            nn.Conv2d(in_chans, embed_dim, 3, stride, 1, bias=True, groups=embed_dim, **dd),
-        )
+        self.proj = msnn.SequentialCell(
+            [
+            nn.Conv2d(in_chans, embed_dim, 3, stride, 1, bias=True, groups=embed_dim, **dd)
+        ])  # 存在 *args/**kwargs，需手动确认参数映射;
         self.stride = stride
 
-    def forward(self, x, size: Size_):
+    def construct(self, x, size: Size_):
         B, N, C = x.shape
-        cnn_feat_token = x.transpose(1, 2).view(B, C, *size)
+        cnn_feat_token = x.transpose(1, 2).view(B, C, *size)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         x = self.proj(cnn_feat_token)
         if self.stride == 1:
             x += cnn_feat_token
@@ -283,7 +289,7 @@         return ['proj.%d.weight' % i for i in range(4)]
 
 
-class PatchEmbed(nn.Module):
+class PatchEmbed(msnn.Cell):
     """ Image to Patch Embedding
     """
 
@@ -307,10 +313,10 @@             f"img_size {img_size} should be divided by patch_size {patch_size}."
         self.H, self.W = img_size[0] // patch_size[0], img_size[1] // patch_size[1]
         self.num_patches = self.H * self.W
-        self.proj = nn.Conv2d(in_chans, embed_dim, kernel_size=patch_size, stride=patch_size, **dd)
-        self.norm = nn.LayerNorm(embed_dim, **dd)
-
-    def forward(self, x) -> Tuple[torch.Tensor, Size_]:
+        self.proj = nn.Conv2d(in_chans, embed_dim, kernel_size=patch_size, stride=patch_size, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.norm = nn.LayerNorm(embed_dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+
+    def construct(self, x) -> Tuple[ms.Tensor, Size_]:
         B, C, H, W = x.shape
 
         x = self.proj(x).flatten(2).transpose(1, 2)
@@ -320,7 +326,7 @@         return x, out_size
 
 
-class Twins(nn.Module):
+class Twins(msnn.Cell):
     """ Twins Vision Transformer (Revisiting Spatial Attention)
 
     Adapted from PVT (PyramidVisionTransformer) class at https://github.com/whai362/PVT.git
@@ -343,7 +349,7 @@             proj_drop_rate: float = 0.,
             attn_drop_rate: float = 0.,
             drop_path_rate: float = 0.,
-            norm_layer: Type[nn.Module] = partial(nn.LayerNorm, eps=1e-6),
+            norm_layer: Type[msnn.Cell] = partial(nn.LayerNorm, eps=1e-6),
             block_cls: Any = Block,
             device=None,
             dtype=None,
@@ -359,21 +365,21 @@ 
         img_size = to_2tuple(img_size)
         prev_chs = in_chans
-        self.patch_embeds = nn.ModuleList()
-        self.pos_drops = nn.ModuleList()
+        self.patch_embeds = msnn.CellList()
+        self.pos_drops = msnn.CellList()
         for i in range(len(depths)):
-            self.patch_embeds.append(PatchEmbed(img_size, patch_size, prev_chs, embed_dims[i], **dd))
-            self.pos_drops.append(nn.Dropout(p=pos_drop_rate))
+            self.patch_embeds.append(PatchEmbed(img_size, patch_size, prev_chs, embed_dims[i], **dd))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+            self.pos_drops.append(nn.Dropout(p = pos_drop_rate))
             prev_chs = embed_dims[i]
             img_size = tuple(t // patch_size for t in img_size)
             patch_size = 2
 
-        self.blocks = nn.ModuleList()
+        self.blocks = msnn.CellList()
         self.feature_info = []
         dpr = calculate_drop_path_rates(drop_path_rate, sum(depths))  # stochastic depth decay rule
         cur = 0
         for k in range(len(depths)):
-            _block = nn.ModuleList([block_cls(
+            _block = msnn.CellList([block_cls(
                 dim=embed_dims[k],
                 num_heads=num_heads[k],
                 mlp_ratio=mlp_ratios[k],
@@ -384,27 +390,27 @@                 sr_ratio=sr_ratios[k],
                 ws=1 if wss is None or i % 2 == 1 else wss[k],
                 **dd,
-            ) for i in range(depths[k])])
+            ) for i in range(depths[k])])  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
             self.blocks.append(_block)
             self.feature_info += [dict(module=f'block.{k}', num_chs=embed_dims[k], reduction=2**(2+k))]
             cur += depths[k]
 
-        self.pos_block = nn.ModuleList([PosConv(embed_dim, embed_dim, **dd) for embed_dim in embed_dims])
-
-        self.norm = norm_layer(self.num_features, **dd)
+        self.pos_block = msnn.CellList([PosConv(embed_dim, embed_dim, **dd) for embed_dim in embed_dims])  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+
+        self.norm = norm_layer(self.num_features, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         # classification head
         self.head_drop = nn.Dropout(drop_rate)
-        self.head = nn.Linear(self.num_features, num_classes, **dd) if num_classes > 0 else nn.Identity()
+        self.head = nn.Linear(self.num_features, num_classes, **dd) if num_classes > 0 else msnn.Identity()  # 存在 *args/**kwargs，需手动确认参数映射;
 
         # init weights
         self.apply(self._init_weights)
 
-    @torch.jit.ignore
+    @ms.jit
     def no_weight_decay(self):
         return set(['pos_block.' + n for n, p in self.pos_block.named_parameters()])
 
-    @torch.jit.ignore
+    @ms.jit
     def group_matcher(self, coarse=False):
         matcher = dict(
             stem=r'^patch_embeds.0',  # stem and embed
@@ -419,12 +425,12 @@         )
         return matcher
 
-    @torch.jit.ignore
+    @ms.jit
     def set_grad_checkpointing(self, enable=True):
         assert not enable, 'gradient checkpointing not supported'
 
-    @torch.jit.ignore
-    def get_classifier(self) -> nn.Module:
+    @ms.jit
+    def get_classifier(self) -> msnn.Cell:
         return self.head
 
     def reset_classifier(self, num_classes: int, global_pool: Optional[str] = None):
@@ -434,16 +440,16 @@             self.global_pool = global_pool
         device = self.head.weight.device if hasattr(self.head, 'weight') else None
         dtype = self.head.weight.dtype if hasattr(self.head, 'weight') else None
-        self.head = nn.Linear(self.num_features, num_classes, device=device, dtype=dtype) if num_classes > 0 else nn.Identity()
+        self.head = nn.Linear(self.num_features, num_classes, dtype = dtype) if num_classes > 0 else msnn.Identity()  # 'torch.nn.Linear':没有对应的mindspore参数 'device' (position 3);
 
     def _init_weights(self, m):
         if isinstance(m, nn.Linear):
             trunc_normal_(m.weight, std=.02)
             if isinstance(m, nn.Linear) and m.bias is not None:
-                nn.init.constant_(m.bias, 0)
+                nn.init.constant_(m.bias, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         elif isinstance(m, nn.LayerNorm):
-            nn.init.constant_(m.bias, 0)
-            nn.init.constant_(m.weight, 1.0)
+            nn.init.constant_(m.bias, 0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+            nn.init.constant_(m.weight, 1.0)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         elif isinstance(m, nn.Conv2d):
             fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
             fan_out //= m.groups
@@ -453,13 +459,13 @@ 
     def forward_intermediates(
             self,
-            x: torch.Tensor,
+            x: ms.Tensor,
             indices: Optional[Union[int, List[int]]] = None,
             norm: bool = False,
             stop_early: bool = False,
             output_fmt: str = 'NCHW',
             intermediates_only: bool = False,
-    ) -> Union[List[torch.Tensor], Tuple[torch.Tensor, List[torch.Tensor]]]:
+    ) -> Union[List[ms.Tensor], Tuple[ms.Tensor, List[ms.Tensor]]]:
         """ Forward features that returns intermediates.
         Args:
             x: Input image tensor
@@ -490,14 +496,14 @@                     x = pos_blk(x, size)  # PEG here
 
             if i < len(self.depths) - 1:
-                x = x.reshape(B, *size, -1).permute(0, 3, 1, 2).contiguous()
+                x = x.reshape(B, *size, -1).permute(0, 3, 1, 2).contiguous()  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
                 if i in take_indices:
                     intermediates.append(x)
             else:
                 if i in take_indices:
                     # only last feature can be normed
                     x_feat = self.norm(x) if norm else x
-                    intermediates.append(x_feat.reshape(B, *size, -1).permute(0, 3, 1, 2).contiguous())
+                    intermediates.append(x_feat.reshape(B, *size, -1).permute(0, 3, 1, 2).contiguous())  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         if intermediates_only:
             return intermediates
@@ -517,7 +523,7 @@         take_indices, max_index = feature_take_indices(len(self.blocks), indices)
         # FIXME add block pruning
         if prune_norm:
-            self.norm = nn.Identity()
+            self.norm = msnn.Identity()
         if prune_head:
             self.reset_classifier(0, '')
         return take_indices
@@ -533,7 +539,7 @@                 if j == 0:
                     x = pos_blk(x, size)  # PEG here
             if i < len(self.depths) - 1:
-                x = x.reshape(B, *size, -1).permute(0, 3, 1, 2).contiguous()
+                x = x.reshape(B, *size, -1).permute(0, 3, 1, 2).contiguous()  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         x = self.norm(x)
         return x
 
@@ -543,7 +549,7 @@         x = self.head_drop(x)
         return x if pre_logits else self.head(x)
 
-    def forward(self, x):
+    def construct(self, x):
         x = self.forward_features(x)
         x = self.forward_head(x)
         return x
@@ -555,7 +561,7 @@         Twins, variant, pretrained,
         feature_cfg=dict(out_indices=out_indices, feature_cls='getter'),
         **kwargs,
-    )
+    )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -586,7 +592,7 @@     model_args = dict(
         patch_size=4, embed_dims=[64, 128, 320, 512], num_heads=[1, 2, 5, 8], mlp_ratios=[8, 8, 4, 4],
         depths=[3, 4, 6, 3], sr_ratios=[8, 4, 2, 1])
-    return _create_twins('twins_pcpvt_small', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_twins('twins_pcpvt_small', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
 
 @register_model
@@ -594,7 +600,7 @@     model_args = dict(
         patch_size=4, embed_dims=[64, 128, 320, 512], num_heads=[1, 2, 5, 8], mlp_ratios=[8, 8, 4, 4],
         depths=[3, 4, 18, 3], sr_ratios=[8, 4, 2, 1])
-    return _create_twins('twins_pcpvt_base', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_twins('twins_pcpvt_base', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
 
 @register_model
@@ -602,7 +608,7 @@     model_args = dict(
         patch_size=4, embed_dims=[64, 128, 320, 512], num_heads=[1, 2, 5, 8], mlp_ratios=[8, 8, 4, 4],
         depths=[3, 8, 27, 3], sr_ratios=[8, 4, 2, 1])
-    return _create_twins('twins_pcpvt_large', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_twins('twins_pcpvt_large', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
 
 @register_model
@@ -610,7 +616,7 @@     model_args = dict(
         patch_size=4, embed_dims=[64, 128, 256, 512], num_heads=[2, 4, 8, 16], mlp_ratios=[4, 4, 4, 4],
         depths=[2, 2, 10, 4], wss=[7, 7, 7, 7], sr_ratios=[8, 4, 2, 1])
-    return _create_twins('twins_svt_small', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_twins('twins_svt_small', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
 
 @register_model
@@ -618,7 +624,7 @@     model_args = dict(
         patch_size=4, embed_dims=[96, 192, 384, 768], num_heads=[3, 6, 12, 24], mlp_ratios=[4, 4, 4, 4],
         depths=[2, 2, 18, 2], wss=[7, 7, 7, 7], sr_ratios=[8, 4, 2, 1])
-    return _create_twins('twins_svt_base', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_twins('twins_svt_base', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
 
 @register_model
@@ -626,4 +632,4 @@     model_args = dict(
         patch_size=4, embed_dims=[128, 256, 512, 1024], num_heads=[4, 8, 16, 32], mlp_ratios=[4, 4, 4, 4],
         depths=[2, 2, 18, 2], wss=[7, 7, 7, 7], sr_ratios=[8, 4, 2, 1])
-    return _create_twins('twins_svt_large', pretrained=pretrained, **dict(model_args, **kwargs))
+    return _create_twins('twins_svt_large', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
