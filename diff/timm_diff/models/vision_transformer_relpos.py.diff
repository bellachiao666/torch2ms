--- pytorch+++ mindspore@@ -1,3 +1,8 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 """ Relative Position Vision Transformer (ViT) in PyTorch
 
 NOTE: these models are experimental / WIP, expect changes
@@ -14,9 +19,9 @@ except ImportError:
     from typing_extensions import Literal
 
-import torch
-import torch.nn as nn
-from torch.jit import Final
+# import torch
+# import torch.nn as nn
+# from torch.jit import Final
 
 from timm.data import IMAGENET_INCEPTION_MEAN, IMAGENET_INCEPTION_STD
 from timm.layers import (
@@ -41,8 +46,8 @@ _logger = logging.getLogger(__name__)
 
 
-class RelPosAttention(nn.Module):
-    fused_attn: Final[bool]
+class RelPosAttention(msnn.Cell):
+    fused_attn: Final[bool]  # 'torch.jit.Final' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
     def __init__(
             self,
@@ -50,10 +55,10 @@             num_heads: int = 8,
             qkv_bias: bool = False,
             qk_norm: bool = False,
-            rel_pos_cls: Optional[Type[nn.Module]] = None,
+            rel_pos_cls: Optional[Type[msnn.Cell]] = None,
             attn_drop: float = 0.,
             proj_drop: float = 0.,
-            norm_layer: Type[nn.Module] = nn.LayerNorm,
+            norm_layer: Type[msnn.Cell] = nn.LayerNorm,
             device=None,
             dtype=None,
     ):
@@ -65,15 +70,15 @@         self.scale = self.head_dim ** -0.5
         self.fused_attn = use_fused_attn()
 
-        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias, **dd)
-        self.q_norm = norm_layer(self.head_dim, **dd) if qk_norm else nn.Identity()
-        self.k_norm = norm_layer(self.head_dim, **dd) if qk_norm else nn.Identity()
-        self.rel_pos = rel_pos_cls(num_heads=num_heads, **dd) if rel_pos_cls else None
+        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
+        self.q_norm = norm_layer(self.head_dim, **dd) if qk_norm else msnn.Identity()  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.k_norm = norm_layer(self.head_dim, **dd) if qk_norm else msnn.Identity()  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.rel_pos = rel_pos_cls(num_heads=num_heads, **dd) if rel_pos_cls else None  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.attn_drop = nn.Dropout(attn_drop)
-        self.proj = nn.Linear(dim, dim, **dd)
+        self.proj = nn.Linear(dim, dim, **dd)  # 存在 *args/**kwargs，需手动确认参数映射;
         self.proj_drop = nn.Dropout(proj_drop)
 
-    def forward(self, x, shared_rel_pos: Optional[torch.Tensor] = None):
+    def construct(self, x, shared_rel_pos: Optional[ms.Tensor] = None):
         B, N, C = x.shape
         qkv = self.qkv(x).reshape(B, N, 3, self.num_heads, self.head_dim).permute(2, 0, 3, 1, 4)
         q, k, v = qkv.unbind(0)
@@ -92,7 +97,7 @@                 q, k, v,
                 attn_mask=attn_bias,
                 dropout_p=self.attn_drop.p if self.training else 0.,
-            )
+            )  # 'torch.nn.functional.scaled_dot_product_attention' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         else:
             q = q * self.scale
             attn = q @ k.transpose(-2, -1)
@@ -110,7 +115,7 @@         return x
 
 
-class RelPosBlock(nn.Module):
+class RelPosBlock(msnn.Cell):
 
     def __init__(
             self,
@@ -119,19 +124,19 @@             mlp_ratio: float = 4.,
             qkv_bias: bool = False,
             qk_norm: bool = False,
-            rel_pos_cls: Optional[Type[nn.Module]] = None,
+            rel_pos_cls: Optional[Type[msnn.Cell]] = None,
             init_values: Optional[float] = None,
             proj_drop: float = 0.,
             attn_drop: float = 0.,
             drop_path: float = 0.,
-            act_layer: Type[nn.Module] = nn.GELU,
-            norm_layer: Type[nn.Module] = nn.LayerNorm,
+            act_layer: Type[msnn.Cell] = nn.GELU,
+            norm_layer: Type[msnn.Cell] = nn.LayerNorm,
             device=None,
             dtype=None,
     ):
         dd = {'device': device, 'dtype': dtype}
         super().__init__()
-        self.norm1 = norm_layer(dim, **dd)
+        self.norm1 = norm_layer(dim, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.attn = RelPosAttention(
             dim,
             num_heads,
@@ -142,29 +147,29 @@             proj_drop=proj_drop,
             norm_layer=norm_layer,
             **dd,
-        )
-        self.ls1 = LayerScale(dim, init_values=init_values, **dd) if init_values else nn.Identity()
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.ls1 = LayerScale(dim, init_values=init_values, **dd) if init_values else msnn.Identity()  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         # NOTE: drop path for stochastic depth, we shall see if this is better than dropout here
-        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
-
-        self.norm2 = norm_layer(dim, **dd)
+        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
+
+        self.norm2 = norm_layer(dim, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.mlp = Mlp(
             in_features=dim,
             hidden_features=int(dim * mlp_ratio),
             act_layer=act_layer,
             drop=proj_drop,
             **dd,
-        )
-        self.ls2 = LayerScale(dim, init_values=init_values, **dd) if init_values else nn.Identity()
-        self.drop_path2 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
-
-    def forward(self, x, shared_rel_pos: Optional[torch.Tensor] = None):
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.ls2 = LayerScale(dim, init_values=init_values, **dd) if init_values else msnn.Identity()  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.drop_path2 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
+
+    def construct(self, x, shared_rel_pos: Optional[ms.Tensor] = None):
         x = x + self.drop_path1(self.ls1(self.attn(self.norm1(x), shared_rel_pos=shared_rel_pos)))
         x = x + self.drop_path2(self.ls2(self.mlp(self.norm2(x))))
         return x
 
 
-class ResPostRelPosBlock(nn.Module):
+class ResPostRelPosBlock(msnn.Cell):
 
     def __init__(
             self,
@@ -173,13 +178,13 @@             mlp_ratio: float = 4.,
             qkv_bias: bool = False,
             qk_norm: bool = False,
-            rel_pos_cls: Optional[Type[nn.Module]] = None,
+            rel_pos_cls: Optional[Type[msnn.Cell]] = None,
             init_values: Optional[float] = None,
             proj_drop: float = 0.,
             attn_drop: float = 0.,
             drop_path: float = 0.,
-            act_layer: Type[nn.Module] = nn.GELU,
-            norm_layer: Type[nn.Module] = nn.LayerNorm,
+            act_layer: Type[msnn.Cell] = nn.GELU,
+            norm_layer: Type[msnn.Cell] = nn.LayerNorm,
             device=None,
             dtype=None,
     ):
@@ -197,9 +202,9 @@             proj_drop=proj_drop,
             norm_layer=norm_layer,
             **dd,
-        )
-        self.norm1 = norm_layer(dim, **dd)
-        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.norm1 = norm_layer(dim, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.drop_path1 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
 
         self.mlp = Mlp(
             in_features=dim,
@@ -207,25 +212,25 @@             act_layer=act_layer,
             drop=proj_drop,
             **dd,
-        )
-        self.norm2 = norm_layer(dim, **dd)
-        self.drop_path2 = DropPath(drop_path) if drop_path > 0. else nn.Identity()
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.norm2 = norm_layer(dim, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+        self.drop_path2 = DropPath(drop_path) if drop_path > 0. else msnn.Identity()
 
         self.init_weights()
 
     def init_weights(self):
         # NOTE this init overrides that base model init with specific changes for the block type
         if self.init_values is not None:
-            nn.init.constant_(self.norm1.weight, self.init_values)
-            nn.init.constant_(self.norm2.weight, self.init_values)
-
-    def forward(self, x, shared_rel_pos: Optional[torch.Tensor] = None):
+            nn.init.constant_(self.norm1.weight, self.init_values)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+            nn.init.constant_(self.norm2.weight, self.init_values)  # 'torch.nn.init.constant_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
+
+    def construct(self, x, shared_rel_pos: Optional[ms.Tensor] = None):
         x = x + self.drop_path1(self.norm1(self.attn(x, shared_rel_pos=shared_rel_pos)))
         x = x + self.drop_path2(self.norm2(self.mlp(x)))
         return x
 
 
-class VisionTransformerRelPos(nn.Module):
+class VisionTransformerRelPos(msnn.Cell):
     """ Vision Transformer w/ Relative Position Bias
 
     Differing from classic vit, this impl
@@ -260,10 +265,10 @@             drop_path_rate: float = 0.,
             weight_init: Literal['skip', 'jax', 'moco', ''] = 'skip',
             fix_init: bool = False,
-            embed_layer: Type[nn.Module] = PatchEmbed,
+            embed_layer: Type[msnn.Cell] = PatchEmbed,
             norm_layer: Optional[LayerType] = None,
             act_layer: Optional[LayerType] = None,
-            block_fn: Type[nn.Module] = RelPosBlock,
+            block_fn: Type[msnn.Cell] = RelPosBlock,
             device=None,
             dtype=None,
     ):
@@ -314,7 +319,7 @@             in_chans=in_chans,
             embed_dim=embed_dim,
             **dd,
-        )
+        )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         feat_size = self.patch_embed.grid_size
         r = self.patch_embed.feat_ratio() if hasattr(self.patch_embed, 'feat_ratio') else patch_size
 
@@ -324,19 +329,19 @@                 rel_pos_args['hidden_dim'] = rel_pos_dim
             if 'swin' in rel_pos_type:
                 rel_pos_args['mode'] = 'swin'
-            rel_pos_cls = partial(RelPosMlp, **rel_pos_args)
+            rel_pos_cls = partial(RelPosMlp, **rel_pos_args)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         else:
-            rel_pos_cls = partial(RelPosBias, **rel_pos_args)
+            rel_pos_cls = partial(RelPosBias, **rel_pos_args)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.shared_rel_pos = None
         if shared_rel_pos:
-            self.shared_rel_pos = rel_pos_cls(num_heads=num_heads, **dd)
+            self.shared_rel_pos = rel_pos_cls(num_heads=num_heads, **dd)  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
             # NOTE shared rel pos currently mutually exclusive w/ per-block, but could support both...
             rel_pos_cls = None
 
-        self.cls_token = nn.Parameter(torch.zeros(1, self.num_prefix_tokens, embed_dim, **dd)) if class_token else None
+        self.cls_token = ms.Parameter(mint.zeros(1, self.num_prefix_tokens, embed_dim, **dd)) if class_token else None  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         dpr = calculate_drop_path_rates(drop_path_rate, depth)  # stochastic depth decay rule
-        self.blocks = nn.ModuleList([
+        self.blocks = msnn.CellList([
             block_fn(
                 dim=embed_dim,
                 num_heads=num_heads,
@@ -352,15 +357,15 @@                 act_layer=act_layer,
                 **dd,
             )
-            for i in range(depth)])
+            for i in range(depth)])  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.feature_info = [
             dict(module=f'blocks.{i}', num_chs=embed_dim, reduction=r) for i in range(depth)]
-        self.norm = norm_layer(embed_dim, **dd) if not fc_norm else nn.Identity()
+        self.norm = norm_layer(embed_dim, **dd) if not fc_norm else msnn.Identity()  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
 
         # Classifier Head
-        self.fc_norm = norm_layer(embed_dim, **dd) if fc_norm else nn.Identity()
+        self.fc_norm = norm_layer(embed_dim, **dd) if fc_norm else msnn.Identity()  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
         self.head_drop = nn.Dropout(drop_rate)
-        self.head = nn.Linear(self.embed_dim, num_classes, **dd) if num_classes > 0 else nn.Identity()
+        self.head = nn.Linear(self.embed_dim, num_classes, **dd) if num_classes > 0 else msnn.Identity()  # 存在 *args/**kwargs，需手动确认参数映射;
 
         if weight_init != 'skip':
             self.init_weights(weight_init)
@@ -370,7 +375,7 @@     def init_weights(self, mode=''):
         assert mode in ('jax', 'moco', '')
         if self.cls_token is not None:
-            nn.init.normal_(self.cls_token, std=1e-6)
+            nn.init.normal_(self.cls_token, std=1e-6)  # 'torch.nn.init.normal_' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         named_apply(get_init_weights_vit(mode), self)
 
     def fix_init_weight(self):
@@ -381,23 +386,23 @@             rescale(layer.attn.proj.weight.data, layer_id + 1)
             rescale(layer.mlp.fc2.weight.data, layer_id + 1)
 
-    @torch.jit.ignore
+    @ms.jit
     def no_weight_decay(self):
         return {'cls_token'}
 
-    @torch.jit.ignore
+    @ms.jit
     def group_matcher(self, coarse=False):
         return dict(
             stem=r'^cls_token|patch_embed',  # stem and embed
             blocks=[(r'^blocks\.(\d+)', None), (r'^norm', (99999,))]
         )
 
-    @torch.jit.ignore
+    @ms.jit
     def set_grad_checkpointing(self, enable=True):
         self.grad_checkpointing = enable
 
-    @torch.jit.ignore
-    def get_classifier(self) -> nn.Module:
+    @ms.jit
+    def get_classifier(self) -> msnn.Cell:
         return self.head
 
     def reset_classifier(self, num_classes: int, global_pool: Optional[str] = None, device=None, dtype=None):
@@ -406,18 +411,18 @@         if global_pool is not None:
             assert global_pool in ('', 'avg', 'token')
             self.global_pool = global_pool
-        self.head = nn.Linear(self.embed_dim, num_classes, **dd) if num_classes > 0 else nn.Identity()
+        self.head = nn.Linear(self.embed_dim, num_classes, **dd) if num_classes > 0 else msnn.Identity()  # 存在 *args/**kwargs，需手动确认参数映射;
 
     def forward_intermediates(
             self,
-            x: torch.Tensor,
+            x: ms.Tensor,
             indices: Optional[Union[int, List[int]]] = None,
             return_prefix_tokens: bool = False,
             norm: bool = False,
             stop_early: bool = False,
             output_fmt: str = 'NCHW',
             intermediates_only: bool = False,
-    ) -> Union[List[torch.Tensor], Tuple[torch.Tensor, List[torch.Tensor]]]:
+    ) -> Union[List[ms.Tensor], Tuple[ms.Tensor, List[ms.Tensor]]]:
         """ Forward features that returns intermediates.
 
         Args:
@@ -440,14 +445,16 @@         B, _, height, width = x.shape
         x = self.patch_embed(x)
         if self.cls_token is not None:
-            x = torch.cat((self.cls_token.expand(x.shape[0], -1, -1), x), dim=1)
+            x = mint.cat((self.cls_token.expand(x.shape[0], -1, -1), x), dim=1)
 
         shared_rel_pos = self.shared_rel_pos.get_bias() if self.shared_rel_pos is not None else None
+        # 'torch.jit.is_scripting' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         if torch.jit.is_scripting() or not stop_early:  # can't slice blocks in torchscript
             blocks = self.blocks
         else:
             blocks = self.blocks[:max_index + 1]
         for i, blk in enumerate(blocks):
+            # 'torch.jit.is_scripting' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
             if self.grad_checkpointing and not torch.jit.is_scripting():
                 x = checkpoint(blk, x, shared_rel_pos=shared_rel_pos)
             else:
@@ -465,6 +472,7 @@             # reshape to BCHW output format
             H, W = self.patch_embed.dynamic_feat_size((height, width))
             intermediates = [y.reshape(B, H, W, -1).permute(0, 3, 1, 2).contiguous() for y in intermediates]
+        # 'torch.jit.is_scripting' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
         if not torch.jit.is_scripting() and return_prefix_tokens:
             # return_prefix not support in torchscript due to poor type handling
             intermediates = list(zip(intermediates, prefix_tokens))
@@ -487,19 +495,20 @@         take_indices, max_index = feature_take_indices(len(self.blocks), indices)
         self.blocks = self.blocks[:max_index + 1]  # truncate blocks
         if prune_norm:
-            self.norm = nn.Identity()
+            self.norm = msnn.Identity()
         if prune_head:
-            self.fc_norm = nn.Identity()
+            self.fc_norm = msnn.Identity()
             self.reset_classifier(0, '')
         return take_indices
 
     def forward_features(self, x):
         x = self.patch_embed(x)
         if self.cls_token is not None:
-            x = torch.cat((self.cls_token.expand(x.shape[0], -1, -1), x), dim=1)
+            x = mint.cat((self.cls_token.expand(x.shape[0], -1, -1), x), dim=1)
 
         shared_rel_pos = self.shared_rel_pos.get_bias() if self.shared_rel_pos is not None else None
         for blk in self.blocks:
+            # 'torch.jit.is_scripting' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
             if self.grad_checkpointing and not torch.jit.is_scripting():
                 x = checkpoint(blk, x, shared_rel_pos=shared_rel_pos)
             else:
@@ -514,7 +523,7 @@         x = self.head_drop(x)
         return x if pre_logits else self.head(x)
 
-    def forward(self, x):
+    def construct(self, x):
         x = self.forward_features(x)
         x = self.forward_head(x)
         return x
@@ -526,7 +535,7 @@         VisionTransformerRelPos, variant, pretrained,
         feature_cfg=dict(out_indices=out_indices, feature_cls='getter'),
         **kwargs,
-    )
+    )  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -588,7 +597,7 @@     """
     model_args = dict(patch_size=32, embed_dim=896, depth=12, num_heads=14, block_fn=ResPostRelPosBlock)
     model = _create_vision_transformer_relpos(
-        'vit_relpos_base_patch32_plus_rpn_256', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_relpos_base_patch32_plus_rpn_256', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -598,7 +607,7 @@     """
     model_args = dict(patch_size=16, embed_dim=896, depth=12, num_heads=14)
     model = _create_vision_transformer_relpos(
-        'vit_relpos_base_patch16_plus_240', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_relpos_base_patch16_plus_240', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -608,7 +617,7 @@     """
     model_args = dict(patch_size=16, embed_dim=384, depth=12, num_heads=6, qkv_bias=False, fc_norm=True)
     model = _create_vision_transformer_relpos(
-        'vit_relpos_small_patch16_224', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_relpos_small_patch16_224', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -619,7 +628,7 @@     model_args = dict(
         patch_size=16, embed_dim=512, depth=12, num_heads=8, qkv_bias=False, fc_norm=True)
     model = _create_vision_transformer_relpos(
-        'vit_relpos_medium_patch16_224', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_relpos_medium_patch16_224', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -630,7 +639,7 @@     model_args = dict(
         patch_size=16, embed_dim=768, depth=12, num_heads=12, qkv_bias=False, fc_norm=True)
     model = _create_vision_transformer_relpos(
-        'vit_relpos_base_patch16_224', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_relpos_base_patch16_224', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -642,7 +651,7 @@         patch_size=16, embed_dim=384, depth=12, num_heads=6, qkv_bias=False, fc_norm=False,
         rel_pos_dim=384, shared_rel_pos=True)
     model = _create_vision_transformer_relpos(
-        'vit_srelpos_small_patch16_224', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_srelpos_small_patch16_224', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -654,7 +663,7 @@         patch_size=16, embed_dim=512, depth=12, num_heads=8, qkv_bias=False, fc_norm=False,
         rel_pos_dim=512, shared_rel_pos=True)
     model = _create_vision_transformer_relpos(
-        'vit_srelpos_medium_patch16_224', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_srelpos_medium_patch16_224', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -666,7 +675,7 @@         patch_size=16, embed_dim=512, depth=12, num_heads=8, qkv_bias=False, fc_norm=False,
         rel_pos_dim=256, class_token=True, global_pool='token')
     model = _create_vision_transformer_relpos(
-        'vit_relpos_medium_patch16_cls_224', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_relpos_medium_patch16_cls_224', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -677,7 +686,7 @@     model_args = dict(
         patch_size=16, embed_dim=768, depth=12, num_heads=12, qkv_bias=False, class_token=True, global_pool='token')
     model = _create_vision_transformer_relpos(
-        'vit_relpos_base_patch16_cls_224', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_relpos_base_patch16_cls_224', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -690,7 +699,7 @@     model_args = dict(
         patch_size=16, embed_dim=768, depth=12, num_heads=12, qkv_bias=False, fc_norm=True, class_token=True)
     model = _create_vision_transformer_relpos(
-        'vit_relpos_base_patch16_clsgap_224', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_relpos_base_patch16_clsgap_224', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -701,7 +710,7 @@     model_args = dict(
         patch_size=16, embed_dim=384, depth=12, num_heads=6, qkv_bias=False, block_fn=ResPostRelPosBlock)
     model = _create_vision_transformer_relpos(
-        'vit_relpos_small_patch16_rpn_224', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_relpos_small_patch16_rpn_224', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -712,7 +721,7 @@     model_args = dict(
         patch_size=16, embed_dim=512, depth=12, num_heads=8, qkv_bias=False, block_fn=ResPostRelPosBlock)
     model = _create_vision_transformer_relpos(
-        'vit_relpos_medium_patch16_rpn_224', pretrained=pretrained, **dict(model_args, **kwargs))
+        'vit_relpos_medium_patch16_rpn_224', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
     return model
 
 
@@ -723,5 +732,5 @@     model_args = dict(
         patch_size=16, embed_dim=768, depth=12, num_heads=12, qkv_bias=False, block_fn=ResPostRelPosBlock)
     model = _create_vision_transformer_relpos(
-        'vit_relpos_base_patch16_rpn_224', pretrained=pretrained, **dict(model_args, **kwargs))
-    return model
+        'vit_relpos_base_patch16_rpn_224', pretrained=pretrained, **dict(model_args, **kwargs))  # 存在 *args/**kwargs，未转换，需手动确认参数映射;
+    return model
