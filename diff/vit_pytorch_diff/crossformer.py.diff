--- pytorch+++ mindspore@@ -1,8 +1,12 @@-import torch
-from torch import nn, einsum
+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
+# import torch
+# from torch import nn, einsum
 from einops import rearrange
-from einops.layers.torch import Rearrange, Reduce
-import torch.nn.functional as F
+# from einops.layers.torch import Rearrange, Reduce
 
 # helpers
 
@@ -11,7 +15,7 @@ 
 # cross embed layer
 
-class CrossEmbedLayer(nn.Module):
+class CrossEmbedLayer(msnn.Cell):
     def __init__(
         self,
         dim_in,
@@ -27,18 +31,19 @@         dim_scales = [int(dim_out / (2 ** i)) for i in range(1, num_scales)]
         dim_scales = [*dim_scales, dim_out - sum(dim_scales)]
 
-        self.convs = nn.ModuleList([])
+        self.convs = msnn.CellList([])
         for kernel, dim_scale in zip(kernel_sizes, dim_scales):
             self.convs.append(nn.Conv2d(dim_in, dim_scale, kernel, stride = stride, padding = (kernel - stride) // 2))
 
-    def forward(self, x):
+    def construct(self, x):
         fmaps = tuple(map(lambda conv: conv(x), self.convs))
-        return torch.cat(fmaps, dim = 1)
+        return mint.cat(fmaps, dim = 1)
 
 # dynamic positional bias
 
 def DynamicPositionBias(dim):
-    return nn.Sequential(
+    return msnn.SequentialCell(
+        [
         nn.Linear(2, dim),
         nn.LayerNorm(dim),
         nn.ReLU(),
@@ -50,32 +55,33 @@         nn.ReLU(),
         nn.Linear(dim, 1),
         Rearrange('... () -> ...')
-    )
+    ])
 
 # transformer classes
 
-class LayerNorm(nn.Module):
+class LayerNorm(msnn.Cell):
     def __init__(self, dim, eps = 1e-5):
         super().__init__()
         self.eps = eps
-        self.g = nn.Parameter(torch.ones(1, dim, 1, 1))
-        self.b = nn.Parameter(torch.zeros(1, dim, 1, 1))
-
-    def forward(self, x):
-        var = torch.var(x, dim = 1, unbiased = False, keepdim = True)
-        mean = torch.mean(x, dim = 1, keepdim = True)
+        self.g = ms.Parameter(mint.ones(size = (1, dim, 1, 1)))
+        self.b = ms.Parameter(mint.zeros(size = (1, dim, 1, 1)))
+
+    def construct(self, x):
+        var = mint.var(x, dim = 1, keepdim = True)
+        mean = mint.mean(x, dim = 1, keepdim = True)
         return (x - mean) / (var + self.eps).sqrt() * self.g + self.b
 
 def FeedForward(dim, mult = 4, dropout = 0.):
-    return nn.Sequential(
+    return msnn.SequentialCell(
+        [
         LayerNorm(dim),
         nn.Conv2d(dim, dim * mult, 1),
         nn.GELU(),
         nn.Dropout(dropout),
         nn.Conv2d(dim * mult, dim, 1)
-    )
-
-class Attention(nn.Module):
+    ])
+
+class Attention(msnn.Cell):
     def __init__(
         self,
         dim,
@@ -107,16 +113,16 @@ 
         # calculate and store indices for retrieving bias
 
-        pos = torch.arange(window_size)
-        grid = torch.stack(torch.meshgrid(pos, pos, indexing = 'ij'))
+        pos = mint.arange(window_size)
+        grid = mint.stack(mint.meshgrid(pos, pos, indexing = 'ij'))
         grid = rearrange(grid, 'c i j -> (i j) c')
         rel_pos = grid[:, None] - grid[None, :]
         rel_pos += window_size - 1
-        rel_pos_indices = (rel_pos * torch.tensor([2 * window_size - 1, 1])).sum(dim = -1)
+        rel_pos_indices = (rel_pos * torch.tensor([2 * window_size - 1, 1])).sum(dim = -1)  # 'torch.tensor' 未在映射表(api_mapping_out_excel.json)中找到，需手动确认;
 
         self.register_buffer('rel_pos_indices', rel_pos_indices, persistent = False)
 
-    def forward(self, x):
+    def construct(self, x):
         *_, height, width, heads, wsz, device = *x.shape, self.heads, self.window_size, x.device
 
         # prenorm
@@ -139,12 +145,12 @@         q, k, v = map(lambda t: rearrange(t, 'b (h d) x y -> b h (x y) d', h = heads), (q, k, v))
         q = q * self.scale
 
-        sim = einsum('b h i d, b h j d -> b h i j', q, k)
+        sim = mint.einsum('b h i d, b h j d -> b h i j', q, k)
 
         # add dynamic positional bias
 
-        pos = torch.arange(-wsz, wsz + 1, device = device)
-        rel_pos = torch.stack(torch.meshgrid(pos, pos, indexing = 'ij'))
+        pos = mint.arange(-wsz, wsz + 1)  # 'torch.arange':没有对应的mindspore参数 'device' (position 6);
+        rel_pos = mint.stack(mint.meshgrid(pos, pos, indexing = 'ij'))
         rel_pos = rearrange(rel_pos, 'c i j -> (i j) c')
         biases = self.dpb(rel_pos.float())
         rel_pos_bias = biases[self.rel_pos_indices]
@@ -158,7 +164,7 @@ 
         # merge heads
 
-        out = einsum('b h i j, b h j d -> b h i d', attn, v)
+        out = mint.einsum('b h i j, b h j d -> b h i d', attn, v)
         out = rearrange(out, 'b h (x y) d -> b (h d) x y', x = wsz, y = wsz)
         out = self.to_out(out)
 
@@ -171,7 +177,7 @@ 
         return out
 
-class Transformer(nn.Module):
+class Transformer(msnn.Cell):
     def __init__(
         self,
         dim,
@@ -184,17 +190,17 @@         ff_dropout = 0.,
     ):
         super().__init__()
-        self.layers = nn.ModuleList([])
+        self.layers = msnn.CellList([])
 
         for _ in range(depth):
-            self.layers.append(nn.ModuleList([
+            self.layers.append(msnn.CellList([
                 Attention(dim, attn_type = 'short', window_size = local_window_size, dim_head = dim_head, dropout = attn_dropout),
                 FeedForward(dim, dropout = ff_dropout),
                 Attention(dim, attn_type = 'long', window_size = global_window_size, dim_head = dim_head, dropout = attn_dropout),
                 FeedForward(dim, dropout = ff_dropout)
             ]))
 
-    def forward(self, x):
+    def construct(self, x):
         for short_attn, short_ff, long_attn, long_ff in self.layers:
             x = short_attn(x) + x
             x = short_ff(x) + x
@@ -205,7 +211,7 @@ 
 # classes
 
-class CrossFormer(nn.Module):
+class CrossFormer(msnn.Cell):
     def __init__(
         self,
         *,
@@ -244,22 +250,23 @@ 
         # layers
 
-        self.layers = nn.ModuleList([])
+        self.layers = msnn.CellList([])
 
         for (dim_in, dim_out), layers, global_wsz, local_wsz, cel_kernel_sizes, cel_stride in zip(dim_in_and_out, depth, global_window_size, local_window_size, cross_embed_kernel_sizes, cross_embed_strides):
-            self.layers.append(nn.ModuleList([
+            self.layers.append(msnn.CellList([
                 CrossEmbedLayer(dim_in, dim_out, cel_kernel_sizes, stride = cel_stride),
                 Transformer(dim_out, local_window_size = local_wsz, global_window_size = global_wsz, depth = layers, attn_dropout = attn_dropout, ff_dropout = ff_dropout)
             ]))
 
         # final logits
 
-        self.to_logits = nn.Sequential(
+        self.to_logits = msnn.SequentialCell(
+            [
             Reduce('b c h w -> b c', 'mean'),
             nn.Linear(last_dim, num_classes)
-        )
-
-    def forward(self, x):
+        ])
+
+    def construct(self, x):
         for cel, transformer in self.layers:
             x = cel(x)
             x = transformer(x)
