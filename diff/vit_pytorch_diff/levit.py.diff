--- pytorch+++ mindspore@@ -1,11 +1,13 @@+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
 from math import ceil
-
-import torch
-from torch import nn, einsum
-import torch.nn.functional as F
+# from torch import nn, einsum
 
 from einops import rearrange, repeat
-from einops.layers.torch import Rearrange
+# from einops.layers.torch import Rearrange
 
 # helpers
 
@@ -24,20 +26,15 @@ 
 # classes
 
-class FeedForward(nn.Module):
+class FeedForward(msnn.Cell):
     def __init__(self, dim, mult, dropout = 0.):
         super().__init__()
-        self.net = nn.Sequential(
-            nn.Conv2d(dim, dim * mult, 1),
-            nn.Hardswish(),
-            nn.Dropout(dropout),
-            nn.Conv2d(dim * mult, dim, 1),
-            nn.Dropout(dropout)
-        )
-    def forward(self, x):
+        self.net = msnn.SequentialCell(
+            [nn.Conv2d(dim, dim * mult, 1), nn.Hardswish(), nn.Dropout(dropout), nn.Conv2d(dim * mult, dim, 1), nn.Dropout(dropout)])
+    def construct(self, x):
         return self.net(x)
 
-class Attention(nn.Module):
+class Attention(msnn.Cell):
     def __init__(self, dim, fmap_size, heads = 8, dim_key = 32, dim_value = 64, dropout = 0., dim_out = None, downsample = False):
         super().__init__()
         inner_dim_key = dim_key *  heads
@@ -47,9 +44,9 @@         self.heads = heads
         self.scale = dim_key ** -0.5
 
-        self.to_q = nn.Sequential(nn.Conv2d(dim, inner_dim_key, 1, stride = (2 if downsample else 1), bias = False), nn.BatchNorm2d(inner_dim_key))
-        self.to_k = nn.Sequential(nn.Conv2d(dim, inner_dim_key, 1, bias = False), nn.BatchNorm2d(inner_dim_key))
-        self.to_v = nn.Sequential(nn.Conv2d(dim, inner_dim_value, 1, bias = False), nn.BatchNorm2d(inner_dim_value))
+        self.to_q = msnn.SequentialCell([nn.Conv2d(dim, inner_dim_key, 1, stride = (2 if downsample else 1), bias = False), nn.BatchNorm2d(inner_dim_key)])
+        self.to_k = msnn.SequentialCell([nn.Conv2d(dim, inner_dim_key, 1, bias = False), nn.BatchNorm2d(inner_dim_key)])
+        self.to_v = msnn.SequentialCell([nn.Conv2d(dim, inner_dim_value, 1, bias = False), nn.BatchNorm2d(inner_dim_value)])
 
         self.attend = nn.Softmax(dim = -1)
         self.dropout = nn.Dropout(dropout)
@@ -57,22 +54,18 @@         out_batch_norm = nn.BatchNorm2d(dim_out)
         nn.init.zeros_(out_batch_norm.weight)
 
-        self.to_out = nn.Sequential(
-            nn.GELU(),
-            nn.Conv2d(inner_dim_value, dim_out, 1),
-            out_batch_norm,
-            nn.Dropout(dropout)
-        )
+        self.to_out = msnn.SequentialCell(
+            [nn.GELU(), nn.Conv2d(inner_dim_value, dim_out, 1), out_batch_norm, nn.Dropout(dropout)])
 
         # positional bias
 
         self.pos_bias = nn.Embedding(fmap_size * fmap_size, heads)
 
-        q_range = torch.arange(0, fmap_size, step = (2 if downsample else 1))
-        k_range = torch.arange(fmap_size)
+        q_range = mint.arange(0, fmap_size, step = (2 if downsample else 1))
+        k_range = mint.arange(fmap_size)
 
-        q_pos = torch.stack(torch.meshgrid(q_range, q_range, indexing = 'ij'), dim = -1)
-        k_pos = torch.stack(torch.meshgrid(k_range, k_range, indexing = 'ij'), dim = -1)
+        q_pos = mint.stack(mint.meshgrid(q_range, q_range, indexing = 'ij'), dim = -1)
+        k_pos = mint.stack(mint.meshgrid(k_range, k_range, indexing = 'ij'), dim = -1)
 
         q_pos, k_pos = map(lambda t: rearrange(t, 'i j c -> (i j) c'), (q_pos, k_pos))
         rel_pos = (q_pos[:, None, ...] - k_pos[None, :, ...]).abs()
@@ -87,7 +80,7 @@         bias = rearrange(bias, 'i j h -> () h i j')
         return fmap + (bias / self.scale)
 
-    def forward(self, x):
+    def construct(self, x):
         b, n, *_, h = *x.shape, self.heads
 
         q = self.to_q(x)
@@ -96,37 +89,37 @@         qkv = (q, self.to_k(x), self.to_v(x))
         q, k, v = map(lambda t: rearrange(t, 'b (h d) ... -> b h (...) d', h = h), qkv)
 
-        dots = einsum('b h i d, b h j d -> b h i j', q, k) * self.scale
+        dots = mint.einsum('b h i d, b h j d -> b h i j', q, k) * self.scale
 
         dots = self.apply_pos_bias(dots)
 
         attn = self.attend(dots)
         attn = self.dropout(attn)
 
-        out = einsum('b h i j, b h j d -> b h i d', attn, v)
+        out = mint.einsum('b h i j, b h j d -> b h i d', attn, v)
         out = rearrange(out, 'b h (x y) d -> b (h d) x y', h = h, y = y)
         return self.to_out(out)
 
-class Transformer(nn.Module):
+class Transformer(msnn.Cell):
     def __init__(self, dim, fmap_size, depth, heads, dim_key, dim_value, mlp_mult = 2, dropout = 0., dim_out = None, downsample = False):
         super().__init__()
         dim_out = default(dim_out, dim)
-        self.layers = nn.ModuleList([])
+        self.layers = msnn.CellList([])
         self.attn_residual = (not downsample) and dim == dim_out
 
         for _ in range(depth):
-            self.layers.append(nn.ModuleList([
+            self.layers.append(msnn.CellList([
                 Attention(dim, fmap_size = fmap_size, heads = heads, dim_key = dim_key, dim_value = dim_value, dropout = dropout, downsample = downsample, dim_out = dim_out),
                 FeedForward(dim_out, mlp_mult, dropout = dropout)
             ]))
-    def forward(self, x):
+    def construct(self, x):
         for attn, ff in self.layers:
             attn_res = (x if self.attn_residual else 0)
             x = attn(x) + attn_res
             x = ff(x) + x
         return x
 
-class LeViT(nn.Module):
+class LeViT(msnn.Cell):
     def __init__(
         self,
         *,
@@ -150,12 +143,8 @@ 
         assert all(map(lambda t: len(t) == stages, (dims, depths, layer_heads))), 'dimensions, depths, and heads must be a tuple that is less than the designated number of stages'
 
-        self.conv_embedding = nn.Sequential(
-            nn.Conv2d(3, 32, 3, stride = 2, padding = 1),
-            nn.Conv2d(32, 64, 3, stride = 2, padding = 1),
-            nn.Conv2d(64, 128, 3, stride = 2, padding = 1),
-            nn.Conv2d(128, dims[0], 3, stride = 2, padding = 1)
-        )
+        self.conv_embedding = msnn.SequentialCell(
+            [nn.Conv2d(3, 32, 3, stride = 2, padding = 1), nn.Conv2d(32, 64, 3, stride = 2, padding = 1), nn.Conv2d(64, 128, 3, stride = 2, padding = 1), nn.Conv2d(128, dims[0], 3, stride = 2, padding = 1)])
 
         fmap_size = image_size // (2 ** 4)
         layers = []
@@ -169,17 +158,15 @@                 layers.append(Transformer(dim, fmap_size, 1, heads * 2, dim_key, dim_value, dim_out = next_dim, downsample = True))
                 fmap_size = ceil(fmap_size / 2)
 
-        self.backbone = nn.Sequential(*layers)
+        self.backbone = msnn.SequentialCell([layers])
 
-        self.pool = nn.Sequential(
-            nn.AdaptiveAvgPool2d(1),
-            Rearrange('... () () -> ...')
-        )
+        self.pool = msnn.SequentialCell(
+            [nn.AdaptiveAvgPool2d(1), Rearrange('... () () -> ...')])
 
         self.distill_head = nn.Linear(dim, num_distill_classes) if exists(num_distill_classes) else always(None)
         self.mlp_head = nn.Linear(dim, num_classes)
 
-    def forward(self, img):
+    def construct(self, img):
         x = self.conv_embedding(img)
 
         x = self.backbone(x)        
