--- pytorch+++ mindspore@@ -1,11 +1,14 @@-import torch
-from torch import nn
-import torch.nn.functional as F
+import mindspore as ms
+import mindspore.nn as msnn
+import mindspore.ops as msops
+import mindspore.mint as mint
+from mindspore.mint import nn, ops
+# from torch import nn
 from einops import repeat
 
-from vit_pytorch.vit import Transformer
+# from vit_pytorch.vit import Transformer
 
-class MAE(nn.Module):
+class MAE(msnn.Cell):
     def __init__(
         self,
         *,
@@ -26,19 +29,19 @@         num_patches, encoder_dim = encoder.pos_embedding.shape[-2:]
 
         self.to_patch = encoder.to_patch_embedding[0]
-        self.patch_to_emb = nn.Sequential(*encoder.to_patch_embedding[1:])
+        self.patch_to_emb = msnn.SequentialCell([encoder.to_patch_embedding[1:]])
 
         pixel_values_per_patch = encoder.to_patch_embedding[2].weight.shape[-1]
 
         # decoder parameters
         self.decoder_dim = decoder_dim
-        self.enc_to_dec = nn.Linear(encoder_dim, decoder_dim) if encoder_dim != decoder_dim else nn.Identity()
-        self.mask_token = nn.Parameter(torch.randn(decoder_dim))
+        self.enc_to_dec = nn.Linear(encoder_dim, decoder_dim) if encoder_dim != decoder_dim else msnn.Identity()
+        self.mask_token = ms.Parameter(mint.randn(decoder_dim))
         self.decoder = Transformer(dim = decoder_dim, depth = decoder_depth, heads = decoder_heads, dim_head = decoder_dim_head, mlp_dim = decoder_dim * 4)
         self.decoder_pos_emb = nn.Embedding(num_patches, decoder_dim)
         self.to_pixels = nn.Linear(decoder_dim, pixel_values_per_patch)
 
-    def forward(self, img):
+    def construct(self, img):
         device = img.device
 
         # get patches
@@ -57,12 +60,12 @@         # calculate of patches needed to be masked, and get random indices, dividing it up for mask vs unmasked
 
         num_masked = int(self.masking_ratio * num_patches)
-        rand_indices = torch.rand(batch, num_patches, device = device).argsort(dim = -1)
+        rand_indices = mint.rand(size = (batch, num_patches)).argsort(dim = -1)  # 'torch.rand':没有对应的mindspore参数 'device' (position 5);
         masked_indices, unmasked_indices = rand_indices[:, :num_masked], rand_indices[:, num_masked:]
 
         # get the unmasked tokens to be encoded
 
-        batch_range = torch.arange(batch, device = device)[:, None]
+        batch_range = mint.arange(batch)[:, None]  # 'torch.arange':没有对应的mindspore参数 'device' (position 6);
         tokens = tokens[batch_range, unmasked_indices]
 
         # get the patches to be masked for the final reconstruction loss
@@ -88,7 +91,7 @@ 
         # concat the masked tokens to the decoder tokens and attend with decoder
         
-        decoder_tokens = torch.zeros(batch, num_patches, self.decoder_dim, device=device)
+        decoder_tokens = mint.zeros(size = (batch, num_patches, self.decoder_dim))  # 'torch.zeros':没有对应的mindspore参数 'device' (position 4);
         decoder_tokens[batch_range, unmasked_indices] = unmasked_decoder_tokens
         decoder_tokens[batch_range, masked_indices] = mask_tokens
         decoded_tokens = self.decoder(decoder_tokens)
@@ -100,5 +103,5 @@ 
         # calculate reconstruction loss
 
-        recon_loss = F.mse_loss(pred_pixel_values, masked_patches)
+        recon_loss = nn.functional.mse_loss(pred_pixel_values, masked_patches)
         return recon_loss
